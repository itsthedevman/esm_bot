# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `celluloid-pool` gem.
# Please instead update this file by running `bin/tapioca gem celluloid-pool`.

# source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#1
module Celluloid
  include ::Celluloid::InstanceMethods

  mixes_in_class_methods ::Celluloid::ClassMethods
  mixes_in_class_methods ::Celluloid::Internals::Properties

  # source://forwardable/1.3.1/forwardable.rb#226
  def [](*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def []=(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#317
  def abort(cause); end

  # source://celluloid/0.17.4/lib/celluloid.rb#431
  def after(interval, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#450
  def async(meth = T.unsafe(nil), *args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#347
  def call_chain_id; end

  # source://celluloid/0.17.4/lib/celluloid.rb#342
  def current_actor; end

  # source://celluloid/0.17.4/lib/celluloid.rb#443
  def defer(&block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#436
  def every(interval, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#420
  def exclusive(&block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#425
  def exclusive?; end

  # source://celluloid/0.17.4/lib/celluloid.rb#455
  def future(meth = T.unsafe(nil), *args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#372
  def link(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#387
  def linked_to?(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#357
  def links; end

  # source://celluloid/0.17.4/lib/celluloid.rb#362
  def monitor(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#382
  def monitoring?(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#392
  def receive(timeout = T.unsafe(nil), &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#81
  def services; end

  # source://celluloid/0.17.4/lib/celluloid.rb#332
  def signal(name, value = T.unsafe(nil)); end

  # source://celluloid/0.17.4/lib/celluloid.rb#402
  def sleep(interval); end

  # source://celluloid/0.17.4/lib/celluloid.rb#352
  def tasks; end

  # source://celluloid/0.17.4/lib/celluloid.rb#327
  def terminate; end

  # source://celluloid/0.17.4/lib/celluloid.rb#412
  def timeout(duration); end

  # source://celluloid/0.17.4/lib/celluloid.rb#377
  def unlink(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#367
  def unmonitor(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#337
  def wait(name); end

  class << self
    # source://celluloid/0.17.4/lib/celluloid.rb#81
    def actor?; end

    # source://celluloid/0.17.4/lib/celluloid.rb#34
    def actor_system; end

    # source://celluloid/0.17.4/lib/celluloid.rb#27
    def actor_system=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#145
    def boot; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def cores; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def cpus; end

    # source://celluloid/0.17.4/lib/celluloid.rb#119
    def detect_recursion; end

    # source://celluloid/0.17.4/lib/celluloid.rb#103
    def dump(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#131
    def exception_handler(&block); end

    # source://celluloid/0.17.4/lib/celluloid.rb#30
    def group_class; end

    # source://celluloid/0.17.4/lib/celluloid.rb#30
    def group_class=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#42
    def included(klass); end

    # source://celluloid/0.17.4/lib/celluloid.rb#150
    def init; end

    # source://celluloid/0.17.4/lib/celluloid.rb#29
    def log_actor_crashes; end

    # source://celluloid/0.17.4/lib/celluloid.rb#29
    def log_actor_crashes=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#28
    def logger; end

    # source://celluloid/0.17.4/lib/celluloid.rb#28
    def logger=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#86
    def mailbox; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def ncpus; end

    # source://celluloid/0.17.4/lib/celluloid.rb#114
    def public_registry; end

    # source://celluloid-essentials/0.20.5/lib/celluloid/notifications.rb#92
    def publish(*args); end

    # source://celluloid/0.17.4/lib/celluloid.rb#162
    def register_shutdown; end

    # source://celluloid/0.17.4/lib/celluloid.rb#158
    def running?; end

    # source://celluloid/0.17.4/lib/celluloid.rb#183
    def shutdown; end

    # source://celluloid/0.17.4/lib/celluloid.rb#32
    def shutdown_timeout; end

    # source://celluloid/0.17.4/lib/celluloid.rb#32
    def shutdown_timeout=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#103
    def stack_dump(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#109
    def stack_summary(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#154
    def start; end

    # source://celluloid/0.17.4/lib/celluloid.rb#109
    def summarize(output = T.unsafe(nil)); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#5
    def supervise(*args, &block); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#10
    def supervise_as(name, *args, &block); end

    # source://celluloid/0.17.4/lib/celluloid.rb#135
    def suspend(status, waiter); end

    # source://celluloid/0.17.4/lib/celluloid.rb#31
    def task_class; end

    # source://celluloid/0.17.4/lib/celluloid.rb#31
    def task_class=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#91
    def uuid; end

    # source://celluloid/0.17.4/lib/celluloid.rb#187
    def version; end
  end
end

# source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#4
module Celluloid::ClassMethods
  extend ::Forwardable

  # source://celluloid/0.17.4/lib/celluloid.rb#242
  def ===(other); end

  # source://celluloid/0.17.4/lib/celluloid.rb#222
  def actor_options; end

  # source://celluloid/0.17.4/lib/celluloid.rb#217
  def actor_system; end

  # source://celluloid/0.17.4/lib/celluloid.rb#232
  def behavior_options; end

  # source://celluloid/0.17.4/lib/celluloid.rb#194
  def new(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#202
  def new_link(*args, &block); end

  # Create a new pool of workers. Accepts the following options:
  #
  # * size: how many workers to create. Default is worker per CPU core
  # * args: array of arguments to pass when creating a worker
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#12
  def pool(config = T.unsafe(nil), &block); end

  # Same as pool, but links to the pool manager
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#18
  def pool_link(klass, config = T.unsafe(nil), &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def pooling_options(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#213
  def run(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#194
  def spawn(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#202
  def spawn_link(*args, &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#17
  def supervise(*args, &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#22
  def supervise_as(name, *args, &block); end
end

# source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#2
module Celluloid::Supervision
  class << self
    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#52
    def router(*_args); end
  end
end

# source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#3
class Celluloid::Supervision::Container
  extend ::Forwardable

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#60
  def initialize(options = T.unsafe(nil)); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#110
  def [](actor_name); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#100
  def actors; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#71
  def add(configuration); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#79
  def add_accessors(configuration); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#104
  def find(actor); end

  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#28
  def pool(klass, config = T.unsafe(nil), &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def pooling_options(*args, &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#57
  def registry; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#57
  def registry=(_arg0); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#94
  def remove(actor); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#91
  def remove_accessors; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#115
  def restart_actor(actor, reason); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#128
  def shutdown; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#95
  def supervise(*args, &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#100
  def supervise_as(name, *args, &block); end

  private

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#135
  def finalize; end

  class << self
    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#28
    def blocks; end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#10
    def define(options); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#14
    def deploy(options); end

    # source://celluloid/0.17.4/lib/celluloid.rb#71
    def exclusive(*args); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_actor(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_methods(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def execute_block_on_receiver(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exit_handler_name(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def finalizer(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def group_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_size(value = T.unsafe(nil), *extra); end

    # Register a pool of actors to be launched on group startup
    #
    # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#39
    def pool(klass, config, &block); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def proxy_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#70
    def run(*args); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#60
    def run!(*args); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#80
    def supervise(*args, &block); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#87
    def supervise_as(name, *args, &block); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def task_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container.rb#18
    def top(options); end

    # source://celluloid/0.17.4/lib/celluloid.rb#67
    def trap_exit(*args); end
  end
end

# source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#33
class Celluloid::Supervision::Container::Instance
  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#10
  def initialize(configuration = T.unsafe(nil)); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#6
  def actor; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#67
  def cleanup; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#6
  def name; end

  # Returns the value of attribute pool.
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#34
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#34
  def pool=(_arg0); end

  # Returns the value of attribute pool_size.
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#34
  def pool_size; end

  # Sets the attribute pool_size
  #
  # @param value the value to set the attribute pool_size to.
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#34
  def pool_size=(_arg0); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#52
  def restart; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#32
  def start; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#61
  def terminate; end

  private

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#73
  def add_accessors; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#107
  def invoke_injection(name); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#115
  def prepare_args(args); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#94
  def remove_accessors; end
end

# Manages a fixed-size pool of actors
# Delegates work (i.e. methods) and supervises actors
# Don't use this class directly. Instead use MyKlass.pool
#
# source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#7
class Celluloid::Supervision::Container::Pool
  include ::Celluloid
  include ::Celluloid::InstanceMethods
  include ::Celluloid::Supervision::Container::Behavior
  extend ::Celluloid::ClassMethods
  extend ::Celluloid::Internals::Properties

  # @return [Pool] a new instance of Pool
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#15
  def initialize(options = T.unsafe(nil)); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#121
  def __busy; end

  # @return [Boolean]
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#117
  def __busy?(actor); end

  # Spawn a new worker for every crashed one
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#160
  def __crash_handler__(actor, reason); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#125
  def __idle; end

  # @return [Boolean]
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#113
  def __idle?(actor); end

  # Provision a new actor ( take it out of idle, move it into busy, and avail it )
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#144
  def __provision_actor__; end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#29
  def __shutdown__; end

  # Instantiate an actor, add it to the actor Set, and return it
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#136
  def __spawn_actor__; end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#129
  def __state(actor); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#42
  def _send_(method, *args, &block); end

  # Returns the value of attribute actors.
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#13
  def actors; end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#105
  def busy_size; end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#109
  def idle_size; end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#84
  def inspect; end

  # @return [Boolean]
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#68
  def is_a?(klass); end

  # @return [Boolean]
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#72
  def kind_of?(klass); end

  # Since Pool allocates worker objects only just before calling them,
  # we can still help Celluloid::Call detect passing invalid parameters to
  # async methods by checking for those methods on the worker class
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#202
  def method(meth); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#191
  def method_missing(method, *args, &block); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#76
  def methods(include_ancestors = T.unsafe(nil)); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#64
  def name; end

  # @return [Boolean]
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#169
  def respond_to?(meth, include_private = T.unsafe(nil)); end

  # Returns the value of attribute size.
  #
  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#13
  def size; end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#88
  def size=(new_size); end

  # source://celluloid-pool//lib/celluloid/supervision/container/pool.rb#80
  def to_s; end

  class << self
    # source://celluloid/0.17.4/lib/celluloid.rb#71
    def exclusive(*args); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_actor(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_methods(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def execute_block_on_receiver(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exit_handler_name(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def finalizer(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def group_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_size(value = T.unsafe(nil), *extra); end

    # source://celluloid-pool//lib/celluloid/supervision/container/behavior/pool.rb#50
    def pooling_options(config = T.unsafe(nil), mixins = T.unsafe(nil)); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def proxy_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def task_class(value = T.unsafe(nil), *extra); end

    # source://celluloid/0.17.4/lib/celluloid.rb#67
    def trap_exit(*args); end
  end
end
