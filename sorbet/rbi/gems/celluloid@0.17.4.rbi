# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `celluloid` gem.
# Please instead update this file by running `bin/tapioca gem celluloid`.

# TODO: Remove link to Interal::Logger
#
# source://celluloid//lib/celluloid/version.rb#1
module Celluloid
  extend ::Celluloid
  extend ::Forwardable
  include ::Celluloid::InstanceMethods

  mixes_in_class_methods ::Celluloid::ClassMethods
  mixes_in_class_methods ::Celluloid::Internals::Properties

  # source://forwardable/1.3.1/forwardable.rb#226
  def [](*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def []=(*args, &block); end

  # Raise an exception in sender context, but stay running
  #
  # source://celluloid//lib/celluloid.rb#317
  def abort(cause); end

  # Call a block after a given interval, returning a Celluloid::Timer object
  #
  # source://celluloid//lib/celluloid.rb#431
  def after(interval, &block); end

  # Handle async calls within an actor itself
  #
  # source://celluloid//lib/celluloid.rb#450
  def async(meth = T.unsafe(nil), *args, &block); end

  # Obtain the UUID of the current call chain
  #
  # source://celluloid//lib/celluloid.rb#347
  def call_chain_id; end

  # Obtain the current_actor
  #
  # source://celluloid//lib/celluloid.rb#342
  def current_actor; end

  # Perform a blocking or computationally intensive action inside an
  # asynchronous group of threads, allowing the sender to continue processing other
  # messages in its mailbox in the meantime
  #
  # source://celluloid//lib/celluloid.rb#443
  def defer(&block); end

  # Call a block every given interval, returning a Celluloid::Timer object
  #
  # source://celluloid//lib/celluloid.rb#436
  def every(interval, &block); end

  # Run given block in an exclusive mode: all synchronous calls block the whole
  # actor, not only current message processing.
  #
  # source://celluloid//lib/celluloid.rb#420
  def exclusive(&block); end

  # Are we currently exclusive
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid.rb#425
  def exclusive?; end

  # Handle calls to future within an actor itself
  #
  # source://celluloid//lib/celluloid.rb#455
  def future(meth = T.unsafe(nil), *args, &block); end

  # Link this actor to another, allowing it to crash or react to errors
  #
  # source://celluloid//lib/celluloid.rb#372
  def link(actor); end

  # Is this actor linked to another?
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid.rb#387
  def linked_to?(actor); end

  # Obtain the Celluloid::Links for this actor
  #
  # source://celluloid//lib/celluloid.rb#357
  def links; end

  # Watch for exit events from another actor
  #
  # source://celluloid//lib/celluloid.rb#362
  def monitor(actor); end

  # Are we monitoring another actor?
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid.rb#382
  def monitoring?(actor); end

  # Receive an asynchronous message via the actor protocol
  #
  # source://celluloid//lib/celluloid.rb#392
  def receive(timeout = T.unsafe(nil), &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#81
  def services; end

  # Send a signal with the given name to all waiting methods
  #
  # source://celluloid//lib/celluloid.rb#332
  def signal(name, value = T.unsafe(nil)); end

  # Sleep letting the actor continue processing messages
  #
  # source://celluloid//lib/celluloid.rb#402
  def sleep(interval); end

  # Obtain the running tasks for this actor
  #
  # source://celluloid//lib/celluloid.rb#352
  def tasks; end

  # Terminate this actor
  #
  # source://celluloid//lib/celluloid.rb#327
  def terminate; end

  # Timeout on task suspension (eg Sync calls to other actors)
  #
  # source://celluloid//lib/celluloid.rb#412
  def timeout(duration); end

  # Remove links to another actor
  #
  # source://celluloid//lib/celluloid.rb#377
  def unlink(actor); end

  # Stop waiting for exit events from another actor
  #
  # source://celluloid//lib/celluloid.rb#367
  def unmonitor(actor); end

  # Wait for the given signal
  #
  # source://celluloid//lib/celluloid.rb#337
  def wait(name); end

  class << self
    # Are we currently inside of an actor?
    #
    # @return [Boolean]
    #
    # source://celluloid//lib/celluloid.rb#81
    def actor?; end

    # source://celluloid//lib/celluloid.rb#34
    def actor_system; end

    # Default Actor System
    #
    # source://celluloid//lib/celluloid.rb#27
    def actor_system=(_arg0); end

    # source://celluloid//lib/celluloid.rb#145
    def boot; end

    # Obtain the number of CPUs in the system
    #
    # source://celluloid//lib/celluloid.rb#96
    def cores; end

    # Obtain the number of CPUs in the system
    #
    # source://celluloid//lib/celluloid.rb#96
    def cpus; end

    # Detect if a particular call is recursing through multiple actors
    #
    # source://celluloid//lib/celluloid.rb#119
    def detect_recursion; end

    # Perform a stack dump of all actors to the given output object
    #
    # source://celluloid//lib/celluloid.rb#103
    def dump(output = T.unsafe(nil)); end

    # Define an exception handler for actor crashes
    #
    # source://celluloid//lib/celluloid.rb#131
    def exception_handler(&block); end

    # Default internal thread group to use
    #
    # source://celluloid//lib/celluloid.rb#30
    def group_class; end

    # Default internal thread group to use
    #
    # source://celluloid//lib/celluloid.rb#30
    def group_class=(_arg0); end

    # @private
    #
    # source://celluloid//lib/celluloid.rb#42
    def included(klass); end

    # source://celluloid//lib/celluloid.rb#150
    def init; end

    # Returns the value of attribute log_actor_crashes.
    #
    # source://celluloid//lib/celluloid.rb#29
    def log_actor_crashes; end

    # Sets the attribute log_actor_crashes
    #
    # @param value the value to set the attribute log_actor_crashes to.
    #
    # source://celluloid//lib/celluloid.rb#29
    def log_actor_crashes=(_arg0); end

    # Thread-safe logger class
    #
    # source://celluloid//lib/celluloid.rb#28
    def logger; end

    # Thread-safe logger class
    #
    # source://celluloid//lib/celluloid.rb#28
    def logger=(_arg0); end

    # Retrieve the mailbox for the current thread or lazily initialize it
    #
    # source://celluloid//lib/celluloid.rb#86
    def mailbox; end

    # Obtain the number of CPUs in the system
    #
    # source://celluloid//lib/celluloid.rb#96
    def ncpus; end

    # source://celluloid//lib/celluloid.rb#114
    def public_registry; end

    # source://celluloid-essentials/0.20.5/lib/celluloid/notifications.rb#92
    def publish(*args); end

    # source://celluloid//lib/celluloid.rb#162
    def register_shutdown; end

    # @return [Boolean]
    #
    # source://celluloid//lib/celluloid.rb#158
    def running?; end

    # Shut down all running actors
    #
    # source://celluloid//lib/celluloid.rb#183
    def shutdown; end

    # How long actors have to terminate
    #
    # source://celluloid//lib/celluloid.rb#32
    def shutdown_timeout; end

    # How long actors have to terminate
    #
    # source://celluloid//lib/celluloid.rb#32
    def shutdown_timeout=(_arg0); end

    # Perform a stack dump of all actors to the given output object
    #
    # source://celluloid//lib/celluloid.rb#103
    def stack_dump(output = T.unsafe(nil)); end

    # Perform a stack summary of all actors to the given output object
    #
    # source://celluloid//lib/celluloid.rb#109
    def stack_summary(output = T.unsafe(nil)); end

    # source://celluloid//lib/celluloid.rb#154
    def start; end

    # Perform a stack summary of all actors to the given output object
    #
    # source://celluloid//lib/celluloid.rb#109
    def summarize(output = T.unsafe(nil)); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#5
    def supervise(*args, &block); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#10
    def supervise_as(name, *args, &block); end

    # source://celluloid//lib/celluloid.rb#135
    def suspend(status, waiter); end

    # Default task type to use
    #
    # source://celluloid//lib/celluloid.rb#31
    def task_class; end

    # Default task type to use
    #
    # source://celluloid//lib/celluloid.rb#31
    def task_class=(_arg0); end

    # Generate a Universally Unique Identifier
    #
    # source://celluloid//lib/celluloid.rb#91
    def uuid; end

    # source://celluloid//lib/celluloid.rb#187
    def version; end
  end
end

# The sender made an error, not the current actor
#
# source://celluloid//lib/celluloid/exceptions.rb#14
class Celluloid::AbortError < ::Celluloid::Error
  # @return [AbortError] a new instance of AbortError
  #
  # source://celluloid//lib/celluloid/exceptions.rb#16
  def initialize(cause); end

  # Returns the value of attribute cause.
  #
  # source://celluloid//lib/celluloid/exceptions.rb#15
  def cause; end
end

# Actors are Celluloid's concurrency primitive. They're implemented as
# normal Ruby objects wrapped in threads which communicate with asynchronous
# messages.
#
# source://celluloid//lib/celluloid/system_events.rb#2
class Celluloid::Actor
  # @return [Actor] a new instance of Actor
  #
  # source://celluloid//lib/celluloid/actor.rb#102
  def initialize(behavior, options); end

  # Schedule a block to run at the given time
  #
  # source://celluloid//lib/celluloid/actor.rb#238
  def after(interval, &block); end

  # Returns the value of attribute behavior.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def behavior; end

  # source://celluloid//lib/celluloid/actor.rb#139
  def behavior_proxy; end

  # Clean up after this actor
  #
  # source://celluloid//lib/celluloid/actor.rb#314
  def cleanup(exit_event); end

  # source://celluloid//lib/celluloid/actor.rb#291
  def default_exit_handler(event); end

  # Schedule a block to run at the given time
  #
  # source://celluloid//lib/celluloid/actor.rb#243
  def every(interval, &block); end

  # Sets the attribute exit_handler
  #
  # @param value the value to set the attribute exit_handler to.
  #
  # source://celluloid//lib/celluloid/actor.rb#9
  def exit_handler=(_arg0); end

  # Register a new handler for a given pattern
  #
  # source://celluloid//lib/celluloid/actor.rb#223
  def handle(*patterns, &block); end

  # Handle any exceptions that occur within a running actor
  #
  # source://celluloid//lib/celluloid/actor.rb#296
  def handle_crash(exception); end

  # Handle standard low-priority messages
  #
  # source://celluloid//lib/celluloid/actor.rb#282
  def handle_message(message); end

  # Handle high-priority system event messages
  #
  # source://celluloid//lib/celluloid/system_events.rb#4
  def handle_system_event(event); end

  # Perform a linking request with another actor
  #
  # source://celluloid//lib/celluloid/actor.rb#181
  def linking_request(receiver, type); end

  # Returns the value of attribute links.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def links; end

  # Returns the value of attribute mailbox.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def mailbox; end

  # Returns the value of attribute name.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def name; end

  # Returns the value of attribute proxy.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def proxy; end

  # Receive an asynchronous message
  #
  # source://celluloid//lib/celluloid/actor.rb#228
  def receive(timeout = T.unsafe(nil), &block); end

  # Run the actor loop
  #
  # source://celluloid//lib/celluloid/actor.rb#149
  def run; end

  # source://celluloid//lib/celluloid/actor.rb#143
  def setup_thread; end

  # Handle cleaning up this actor after it exits
  #
  # source://celluloid//lib/celluloid/actor.rb#305
  def shutdown(exit_event = T.unsafe(nil)); end

  # Send a signal with the given name to all waiting methods
  #
  # source://celluloid//lib/celluloid/actor.rb#213
  def signal(name, value = T.unsafe(nil)); end

  # Sleep for the given amount of time
  #
  # source://celluloid//lib/celluloid/actor.rb#276
  def sleep(interval); end

  # source://celluloid//lib/celluloid/actor.rb#127
  def start; end

  # Run a method inside a task unless it's exclusive
  #
  # source://celluloid//lib/celluloid/actor.rb#334
  def task(task_type, meta = T.unsafe(nil)); end

  # Returns the value of attribute tasks.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def tasks; end

  # Terminate this actor
  #
  # source://celluloid//lib/celluloid/actor.rb#176
  def terminate; end

  # Returns the value of attribute thread.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def thread; end

  # source://celluloid//lib/celluloid/actor.rb#247
  def timeout(duration); end

  # Returns the value of attribute timers.
  #
  # source://celluloid//lib/celluloid/actor.rb#8
  def timers; end

  # Wait for the given signal
  #
  # source://celluloid//lib/celluloid/actor.rb#218
  def wait(name); end

  class << self
    # source://forwardable/1.3.1/forwardable.rb#226
    def [](*args, &block); end

    # source://forwardable/1.3.1/forwardable.rb#226
    def []=(*args, &block); end

    # Obtain all running actors in the system
    #
    # source://celluloid//lib/celluloid/actor.rb#49
    def all; end

    # Invoke a method asynchronously on an actor via its mailbox
    #
    # source://celluloid//lib/celluloid/actor.rb#37
    def async(mailbox, meth, *args, &block); end

    # Invoke a method on the given actor via its mailbox
    #
    # source://celluloid//lib/celluloid/actor.rb#31
    def call(mailbox, meth, *args, &block); end

    # source://forwardable/1.3.1/forwardable.rb#226
    def clear_registry(*args, &block); end

    # Obtain the current actor
    #
    # source://celluloid//lib/celluloid/actor.rb#17
    def current; end

    # source://forwardable/1.3.1/forwardable.rb#226
    def delete(*args, &block); end

    # Call a method asynchronously and retrieve its value later
    #
    # source://celluloid//lib/celluloid/actor.rb#43
    def future(mailbox, meth, *args, &block); end

    # Wait for an actor to terminate
    #
    # source://celluloid//lib/celluloid/actor.rb#96
    def join(actor, timeout = T.unsafe(nil)); end

    # source://celluloid//lib/celluloid/actor.rb#89
    def kill(actor); end

    # Link to another actor
    #
    # source://celluloid//lib/celluloid/actor.rb#66
    def link(actor); end

    # Are we bidirectionally linked to the given actor?
    #
    # @return [Boolean]
    #
    # source://celluloid//lib/celluloid/actor.rb#83
    def linked_to?(actor); end

    # Watch for exit events from another actor
    #
    # source://celluloid//lib/celluloid/actor.rb#54
    def monitor(actor); end

    # Are we monitoring the given actor?
    #
    # @return [Boolean]
    #
    # source://celluloid//lib/celluloid/actor.rb#78
    def monitoring?(actor); end

    # source://forwardable/1.3.1/forwardable.rb#226
    def registered(*args, &block); end

    # Obtain the name of the current actor
    #
    # source://celluloid//lib/celluloid/actor.rb#24
    def registered_name; end

    # Unlink from another actor
    #
    # source://celluloid//lib/celluloid/actor.rb#72
    def unlink(actor); end

    # Stop waiting for exit events from another actor
    #
    # source://celluloid//lib/celluloid/actor.rb#60
    def unmonitor(actor); end
  end
end

# source://celluloid//lib/celluloid/actor/manager.rb#3
class Celluloid::Actor::Manager
  include ::Celluloid
  include ::Celluloid::InstanceMethods
  extend ::Celluloid::ClassMethods
  extend ::Celluloid::Internals::Properties

  class << self
    # source://celluloid//lib/celluloid.rb#71
    def exclusive(*args); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_actor(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_methods(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def execute_block_on_receiver(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exit_handler_name(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def finalizer(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def group_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_size(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def proxy_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def task_class(value = T.unsafe(nil), *extra); end

    # source://celluloid//lib/celluloid.rb#67
    def trap_exit(*args); end
  end
end

# source://celluloid//lib/celluloid/actor.rb#260
class Celluloid::Actor::Sleeper
  # @return [Sleeper] a new instance of Sleeper
  #
  # source://celluloid//lib/celluloid/actor.rb#261
  def initialize(timers, interval); end

  # source://celluloid//lib/celluloid/actor.rb#266
  def before_suspend(task); end

  # source://celluloid//lib/celluloid/actor.rb#270
  def wait; end
end

# source://celluloid//lib/celluloid/actor/system.rb#6
class Celluloid::Actor::System
  extend ::Forwardable

  # @return [System] a new instance of System
  #
  # source://celluloid//lib/celluloid/actor/system.rb#50
  def initialize; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def [](*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def []=(*args, &block); end

  # source://celluloid//lib/celluloid/actor/system.rb#154
  def assert_inactive; end

  # source://celluloid//lib/celluloid/actor/system.rb#94
  def clear_registry; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def delete(*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def get(*args, &block); end

  # source://celluloid//lib/celluloid/actor/system.rb#75
  def get_thread; end

  # Returns the value of attribute group.
  #
  # source://celluloid//lib/celluloid/actor/system.rb#38
  def group; end

  # source://celluloid//lib/celluloid/actor/system.rb#90
  def registered; end

  # Returns the value of attribute registry.
  #
  # source://celluloid//lib/celluloid/actor/system.rb#38
  def registry; end

  # source://celluloid//lib/celluloid/actor/system.rb#46
  def root_configuration; end

  # the root of the supervisor tree is established at supervision/root
  #
  # source://celluloid//lib/celluloid/actor/system.rb#42
  def root_services; end

  # source://celluloid//lib/celluloid/actor/system.rb#98
  def running; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/actor/system.rb#114
  def running?; end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#86
  def services; end

  # source://forwardable/1.3.1/forwardable.rb#226
  def set(*args, &block); end

  # Shut down all running actors
  #
  # source://celluloid//lib/celluloid/actor/system.rb#119
  def shutdown; end

  # source://celluloid//lib/celluloid/actor/system.rb#158
  def shutdown_timeout; end

  # source://celluloid//lib/celluloid/actor/system.rb#82
  def stack_dump; end

  # source://celluloid//lib/celluloid/actor/system.rb#86
  def stack_summary; end

  # Launch default services
  #
  # source://celluloid//lib/celluloid/actor/system.rb#58
  def start; end

  # source://celluloid//lib/celluloid/actor/system.rb#67
  def within; end
end

# source://celluloid//lib/celluloid/actor/system.rb#10
Celluloid::Actor::System::ROOT_SERVICES = T.let(T.unsafe(nil), Array)

# source://celluloid//lib/celluloid/deprecate.rb#18
Celluloid::ActorSystem = Celluloid::Actor::System

# Warning message added to Celluloid objects accessed outside their actors
#
# source://celluloid//lib/celluloid.rb#24
Celluloid::BARE_OBJECT_WARNING_MESSAGE = T.let(T.unsafe(nil), String)

# Calls represent requests to an actor
#
# source://celluloid//lib/celluloid/calls.rb#3
class Celluloid::Call
  # @return [Call] a new instance of Call
  #
  # source://celluloid//lib/celluloid/calls.rb#6
  def initialize(method, arguments = T.unsafe(nil), block = T.unsafe(nil)); end

  # Returns the value of attribute arguments.
  #
  # source://celluloid//lib/celluloid/calls.rb#4
  def arguments; end

  # Returns the value of attribute block.
  #
  # source://celluloid//lib/celluloid/calls.rb#4
  def block; end

  # source://celluloid//lib/celluloid/calls.rb#37
  def check(obj); end

  # source://celluloid//lib/celluloid/calls.rb#25
  def dispatch(obj); end

  # source://celluloid//lib/celluloid/calls.rb#21
  def execute_block_on_receiver; end

  # Returns the value of attribute method.
  #
  # source://celluloid//lib/celluloid/calls.rb#4
  def method; end
end

# Asynchronous calls don't wait for a response
#
# source://celluloid//lib/celluloid/call/async.rb#4
class Celluloid::Call::Async < ::Celluloid::Call
  # source://celluloid//lib/celluloid/call/async.rb#5
  def dispatch(obj); end
end

# source://celluloid//lib/celluloid/call/block.rb#3
class Celluloid::Call::Block
  # @return [Block] a new instance of Block
  #
  # source://celluloid//lib/celluloid/call/block.rb#4
  def initialize(block_proxy, sender, arguments, task = T.unsafe(nil)); end

  # source://celluloid//lib/celluloid/call/block.rb#12
  def call; end

  # source://celluloid//lib/celluloid/call/block.rb#16
  def dispatch; end

  # Returns the value of attribute task.
  #
  # source://celluloid//lib/celluloid/call/block.rb#10
  def task; end
end

# Synchronous calls wait for a response
#
# source://celluloid//lib/celluloid/call/sync.rb#4
class Celluloid::Call::Sync < ::Celluloid::Call
  # @return [Sync] a new instance of Sync
  #
  # source://celluloid//lib/celluloid/call/sync.rb#7
  def initialize(sender, method, arguments = T.unsafe(nil), block = T.unsafe(nil), task = T.unsafe(nil), chain_id = T.unsafe(nil)); end

  # Returns the value of attribute chain_id.
  #
  # source://celluloid//lib/celluloid/call/sync.rb#5
  def chain_id; end

  # source://celluloid//lib/celluloid/call/sync.rb#31
  def cleanup; end

  # source://celluloid//lib/celluloid/call/sync.rb#14
  def dispatch(obj); end

  # source://celluloid//lib/celluloid/call/sync.rb#36
  def respond(message); end

  # source://celluloid//lib/celluloid/call/sync.rb#40
  def response; end

  # Returns the value of attribute sender.
  #
  # source://celluloid//lib/celluloid/call/sync.rb#5
  def sender; end

  # Returns the value of attribute task.
  #
  # source://celluloid//lib/celluloid/call/sync.rb#5
  def task; end

  # source://celluloid//lib/celluloid/call/sync.rb#44
  def value; end

  # source://celluloid//lib/celluloid/call/sync.rb#48
  def wait; end
end

# Wrap the given subject with an Cell
#
# source://celluloid//lib/celluloid/cell.rb#5
class Celluloid::Cell
  # @return [Cell] a new instance of Cell
  #
  # source://celluloid//lib/celluloid/cell.rb#20
  def initialize(subject, options, actor_options); end

  # source://celluloid//lib/celluloid/cell.rb#56
  def invoke(call); end

  # Returns the value of attribute proxy.
  #
  # source://celluloid//lib/celluloid/cell.rb#46
  def proxy; end

  # Run the user-defined finalizer, if one is set
  #
  # source://celluloid//lib/celluloid/cell.rb#94
  def shutdown; end

  # Returns the value of attribute subject.
  #
  # source://celluloid//lib/celluloid/cell.rb#46
  def subject; end

  # source://celluloid//lib/celluloid/cell.rb#69
  def task(task_type, method_name = T.unsafe(nil), subject = T.unsafe(nil), meta = T.unsafe(nil), &_block); end

  class << self
    # source://celluloid//lib/celluloid/cell.rb#48
    def dispatch; end

    # source://celluloid//lib/celluloid/cell.rb#81
    def shutdown; end
  end
end

# source://celluloid//lib/celluloid/cell.rb#6
class Celluloid::Cell::ExitHandler
  # @return [ExitHandler] a new instance of ExitHandler
  #
  # source://celluloid//lib/celluloid/cell.rb#7
  def initialize(behavior, subject, method_name); end

  # source://celluloid//lib/celluloid/cell.rb#13
  def call(event); end
end

# Class methods added to classes which include Celluloid
#
# source://celluloid//lib/celluloid.rb#193
module Celluloid::ClassMethods
  # source://celluloid//lib/celluloid.rb#242
  def ===(other); end

  # Configuration options for Actor#new
  #
  # source://celluloid//lib/celluloid.rb#222
  def actor_options; end

  # source://celluloid//lib/celluloid.rb#217
  def actor_system; end

  # source://celluloid//lib/celluloid.rb#232
  def behavior_options; end

  # source://celluloid//lib/celluloid.rb#194
  def new(*args, &block); end

  # Create a new actor and link to the current one
  #
  # source://celluloid//lib/celluloid.rb#202
  def new_link(*args, &block); end

  # source://celluloid-pool/0.20.5/lib/celluloid/supervision/container/behavior/pool.rb#12
  def pool(config = T.unsafe(nil), &block); end

  # source://celluloid-pool/0.20.5/lib/celluloid/supervision/container/behavior/pool.rb#18
  def pool_link(klass, config = T.unsafe(nil), &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def pooling_options(*args, &block); end

  # Run an actor in the foreground
  #
  # source://celluloid//lib/celluloid.rb#213
  def run(*args, &block); end

  # source://celluloid//lib/celluloid.rb#194
  def spawn(*args, &block); end

  # Create a new actor and link to the current one
  #
  # source://celluloid//lib/celluloid.rb#202
  def spawn_link(*args, &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#17
  def supervise(*args, &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#22
  def supervise_as(name, *args, &block); end
end

# ConditionVariable-like signaling between tasks and threads
#
# source://celluloid//lib/celluloid/condition.rb#3
class Celluloid::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://celluloid//lib/celluloid/condition.rb#30
  def initialize; end

  # Broadcast a value to all waiting tasks and threads
  #
  # source://celluloid//lib/celluloid/condition.rb#79
  def broadcast(value = T.unsafe(nil)); end

  def inspect; end

  # Send a signal to the first task waiting on this condition
  #
  # source://celluloid//lib/celluloid/condition.rb#66
  def signal(value = T.unsafe(nil)); end

  # Wait for the given signal and return the associated value
  #
  # source://celluloid//lib/celluloid/condition.rb#36
  def wait(timeout = T.unsafe(nil)); end
end

# source://celluloid//lib/celluloid/condition.rb#4
class Celluloid::Condition::Waiter
  # @return [Waiter] a new instance of Waiter
  #
  # source://celluloid//lib/celluloid/condition.rb#5
  def initialize(condition, task, mailbox, timeout); end

  # source://celluloid//lib/celluloid/condition.rb#13
  def <<(message); end

  # Returns the value of attribute condition.
  #
  # source://celluloid//lib/celluloid/condition.rb#11
  def condition; end

  # Returns the value of attribute task.
  #
  # source://celluloid//lib/celluloid/condition.rb#11
  def task; end

  # source://celluloid//lib/celluloid/condition.rb#17
  def wait; end
end

# source://celluloid//lib/celluloid/exceptions.rb#13
class Celluloid::ConditionError < ::Celluloid::Error; end

# Trying to do something to a dead actor
#
# source://celluloid//lib/celluloid/exceptions.rb#8
class Celluloid::DeadActorError < ::Celluloid::Error; end

# Trying to resume a dead task
#
# source://celluloid//lib/celluloid/exceptions.rb#10
class Celluloid::DeadTaskError < ::Celluloid::Error; end

# source://celluloid//lib/celluloid/exceptions.rb#2
class Celluloid::Error < ::StandardError; end

# source://celluloid//lib/celluloid/deprecate.rb#14
Celluloid::EventedMailbox = Celluloid::Mailbox::Evented

# An actor has exited for the given reason
#
# source://celluloid//lib/celluloid/system_events.rb#70
class Celluloid::ExitEvent < ::Celluloid::SystemEvent
  # @return [ExitEvent] a new instance of ExitEvent
  #
  # source://celluloid//lib/celluloid/system_events.rb#78
  def initialize(actor, reason = T.unsafe(nil)); end

  # Returns the value of attribute actor.
  #
  # source://celluloid//lib/celluloid/system_events.rb#71
  def actor; end

  # Returns the value of attribute reason.
  #
  # source://celluloid//lib/celluloid/system_events.rb#71
  def reason; end
end

# source://celluloid//lib/celluloid/exceptions.rb#22
module Celluloid::Feature; end

# source://celluloid//lib/celluloid/exceptions.rb#23
module Celluloid::Feature::Requires; end

# source://celluloid//lib/celluloid/exceptions.rb#26
class Celluloid::Feature::Requires::JRuby < ::Celluloid::Error; end

# source://celluloid//lib/celluloid/exceptions.rb#25
class Celluloid::Feature::Requires::Rubinius < ::Celluloid::Error; end

# source://celluloid//lib/celluloid/exceptions.rb#24
class Celluloid::Feature::Requires::RubiniusOrJRuby < ::Celluloid::Error; end

# Celluloid::Future objects allow methods and blocks to run in the
# background, their values requested later
#
# source://celluloid//lib/celluloid/future.rb#6
class Celluloid::Future
  # @return [Future] a new instance of Future
  #
  # source://celluloid//lib/celluloid/future.rb#28
  def initialize(&block); end

  # Signal this future with the given result value
  #
  # source://celluloid//lib/celluloid/future.rb#104
  def <<(value); end

  # Returns the value of attribute address.
  #
  # source://celluloid//lib/celluloid/future.rb#26
  def address; end

  # Obtain the value for this Future
  #
  # source://celluloid//lib/celluloid/future.rb#66
  def call(timeout = T.unsafe(nil)); end

  # source://celluloid//lib/celluloid/future.rb#121
  def cancel(error); end

  # Execute the given method in future context
  #
  # source://celluloid//lib/celluloid/future.rb#51
  def execute(receiver, method, args, block); end

  # Inspect this Celluloid::Future
  def inspect; end

  # Check if this future has a value yet
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/future.rb#61
  def ready?; end

  # Signal this future with the given result value
  #
  # source://celluloid//lib/celluloid/future.rb#104
  def signal(value); end

  # Obtain the value for this Future
  #
  # source://celluloid//lib/celluloid/future.rb#66
  def value(timeout = T.unsafe(nil)); end

  class << self
    # source://celluloid//lib/celluloid/future.rb#7
    def new(*args, &block); end
  end
end

# Wrapper for result values to distinguish them in mailboxes
#
# source://celluloid//lib/celluloid/future.rb#133
class Celluloid::Future::Result
  # @return [Result] a new instance of Result
  #
  # source://celluloid//lib/celluloid/future.rb#136
  def initialize(result, future); end

  # Returns the value of attribute future.
  #
  # source://celluloid//lib/celluloid/future.rb#134
  def future; end

  # source://celluloid//lib/celluloid/future.rb#141
  def value; end
end

# source://celluloid//lib/celluloid/group.rb#2
class Celluloid::Group
  # @return [Group] a new instance of Group
  #
  # source://celluloid//lib/celluloid/group.rb#5
  def initialize; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/group.rb#51
  def active?; end

  # source://celluloid//lib/celluloid/group.rb#12
  def assert_active; end

  # source://celluloid//lib/celluloid/group.rb#16
  def assert_inactive; end

  # source://celluloid//lib/celluloid/group.rb#59
  def create; end

  # source://celluloid//lib/celluloid/group.rb#25
  def each; end

  # source://celluloid//lib/celluloid/group.rb#47
  def each_actor(&block); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/group.rb#29
  def forked?; end

  # source://celluloid//lib/celluloid/group.rb#55
  def get; end

  # Returns the value of attribute group.
  #
  # source://celluloid//lib/celluloid/group.rb#3
  def group; end

  # Sets the attribute group
  #
  # @param value the value to set the attribute group to.
  #
  # source://celluloid//lib/celluloid/group.rb#3
  def group=(_arg0); end

  # source://celluloid//lib/celluloid/group.rb#40
  def purge(thread); end

  # source://celluloid//lib/celluloid/group.rb#63
  def shutdown; end

  # source://celluloid//lib/celluloid/group.rb#33
  def to_a; end
end

# source://celluloid//lib/celluloid/group/pool.rb#7
class Celluloid::Group::Pool < ::Celluloid::Group
  # @return [Pool] a new instance of Pool
  #
  # source://celluloid//lib/celluloid/group/pool.rb#11
  def initialize; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/group/pool.rb#27
  def busy?; end

  # Returns the value of attribute busy_size.
  #
  # source://celluloid//lib/celluloid/group/pool.rb#31
  def busy_size; end

  # Get a thread from the pool, running the given block
  #
  # source://celluloid//lib/celluloid/group/pool.rb#36
  def get(&block); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/group/pool.rb#23
  def idle?; end

  # Returns the value of attribute idle_size.
  #
  # source://celluloid//lib/celluloid/group/pool.rb#33
  def idle_size; end

  # You do not want to use this. Truly, you do not. There is no scenario when you will.
  # But. If you somehow do.. `Celluloid.group_class = Celluloid::Group::Pool` and weep.
  #
  # source://celluloid//lib/celluloid/group/pool.rb#9
  def max_idle; end

  # You do not want to use this. Truly, you do not. There is no scenario when you will.
  # But. If you somehow do.. `Celluloid.group_class = Celluloid::Group::Pool` and weep.
  #
  # source://celluloid//lib/celluloid/group/pool.rb#9
  def max_idle=(_arg0); end

  # Return a thread to the pool
  #
  # source://celluloid//lib/celluloid/group/pool.rb#57
  def put(thread); end

  # source://celluloid//lib/celluloid/group/pool.rb#73
  def shutdown; end

  private

  # Clean the thread locals of an incoming thread
  #
  # source://celluloid//lib/celluloid/group/pool.rb#111
  def clean_thread_locals(thread); end

  # Create a new thread with an associated queue of procs to run
  #
  # source://celluloid//lib/celluloid/group/pool.rb#90
  def create; end

  # source://celluloid//lib/celluloid/group/pool.rb#120
  def finalize; end
end

# source://celluloid//lib/celluloid/group/spawner.rb#5
class Celluloid::Group::Spawner < ::Celluloid::Group
  # @return [Spawner] a new instance of Spawner
  #
  # source://celluloid//lib/celluloid/group/spawner.rb#8
  def initialize; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/group/spawner.rb#40
  def busy?; end

  # Returns the value of attribute finalizer.
  #
  # source://celluloid//lib/celluloid/group/spawner.rb#6
  def finalizer; end

  # Sets the attribute finalizer
  #
  # @param value the value to set the attribute finalizer to.
  #
  # source://celluloid//lib/celluloid/group/spawner.rb#6
  def finalizer=(_arg0); end

  # source://celluloid//lib/celluloid/group/spawner.rb#12
  def get(&block); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/group/spawner.rb#36
  def idle?; end

  # source://celluloid//lib/celluloid/group/spawner.rb#18
  def shutdown; end

  private

  # source://celluloid//lib/celluloid/group/spawner.rb#46
  def instantiate(proc); end
end

class Celluloid::IncidentReporter
  # source://celluloid-essentials/0.20.5/lib/celluloid/logging/incident_reporter.rb#15
  def initialize(*args); end

  # source://celluloid-essentials/0.20.5/lib/celluloid/logging/incident_reporter.rb#22
  def report(_topic, incident); end

  # source://celluloid-essentials/0.20.5/lib/celluloid/logging/incident_reporter.rb#36
  def silence; end

  # source://celluloid-essentials/0.20.5/lib/celluloid/logging/incident_reporter.rb#44
  def silenced?; end

  # source://celluloid-essentials/0.20.5/lib/celluloid/logging/incident_reporter.rb#40
  def unsilence; end

  class << self
    # source://celluloid//lib/celluloid.rb#71
    def exclusive(*args); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_actor(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exclusive_methods(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def execute_block_on_receiver(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def exit_handler_name(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def finalizer(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def group_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def mailbox_size(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def proxy_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials/0.20.5/lib/celluloid/internals/properties.rb#13
    def task_class(value = T.unsafe(nil), *extra); end

    # source://celluloid//lib/celluloid.rb#67
    def trap_exit(*args); end
  end
end

# These are methods we don't want added to the Celluloid singleton but to be
# defined on all classes that use Celluloid
#
# source://celluloid//lib/celluloid.rb#249
module Celluloid::InstanceMethods
  # source://celluloid//lib/celluloid.rb#306
  def __arity; end

  # Obtain the bare Ruby object the actor is wrapping. This is useful for
  # only a limited set of use cases like runtime metaprogramming. Interacting
  # directly with the bare object foregoes any kind of thread safety that
  # Celluloid would ordinarily provide you, and the object is guaranteed to
  # be shared with at least the actor thread. Tread carefully.
  #
  # Bare objects can be identified via #inspect output:
  #
  #     >> actor
  #      => #<Celluloid::Actor(Foo:0x3fefcb77c194)>
  #     >> actor.bare_object
  #      => #<WARNING: BARE CELLULOID OBJECT (Foo:0x3fefcb77c194)>
  #
  # source://celluloid//lib/celluloid.rb#263
  def bare_object; end

  # source://celluloid//lib/celluloid.rb#284
  def inspect; end

  # Are we being invoked in a different thread from our owner?
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid.rb#269
  def leaked?; end

  # Obtain the name of the current actor
  #
  # source://celluloid//lib/celluloid.rb#279
  def name; end

  # Obtain the name of the current actor
  #
  # source://celluloid//lib/celluloid.rb#279
  def registered_name; end

  # @yield [current_actor]
  #
  # source://celluloid//lib/celluloid.rb#273
  def tap; end

  # Obtain the bare Ruby object the actor is wrapping. This is useful for
  # only a limited set of use cases like runtime metaprogramming. Interacting
  # directly with the bare object foregoes any kind of thread safety that
  # Celluloid would ordinarily provide you, and the object is guaranteed to
  # be shared with at least the actor thread. Tread carefully.
  #
  # Bare objects can be identified via #inspect output:
  #
  #     >> actor
  #      => #<Celluloid::Actor(Foo:0x3fefcb77c194)>
  #     >> actor.bare_object
  #      => #<WARNING: BARE CELLULOID OBJECT (Foo:0x3fefcb77c194)>
  #
  # source://celluloid//lib/celluloid.rb#263
  def wrapped_object; end
end

# source://celluloid//lib/celluloid/deprecate.rb#15
Celluloid::InternalPool = Celluloid::Group::Pool

# source://celluloid//lib/celluloid/exceptions.rb#3
class Celluloid::Interruption < ::Exception; end

# Linking times out after 5 seconds
#
# source://celluloid//lib/celluloid.rb#21
Celluloid::LINKING_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Request to link with another actor
#
# source://celluloid//lib/celluloid/system_events.rb#47
class Celluloid::LinkingRequest < ::Celluloid::SystemEvent::LinkingEvent
  # Returns the value of attribute actor.
  #
  # source://celluloid//lib/celluloid/system_events.rb#48
  def actor; end

  # source://celluloid//lib/celluloid/system_events.rb#54
  def process(links); end

  # Returns the value of attribute type.
  #
  # source://celluloid//lib/celluloid/system_events.rb#48
  def type; end
end

# Response to a link request
#
# source://celluloid//lib/celluloid/system_events.rb#65
class Celluloid::LinkingResponse < ::Celluloid::SystemEvent::LinkingEvent
  # Returns the value of attribute actor.
  #
  # source://celluloid//lib/celluloid/system_events.rb#66
  def actor; end

  # Returns the value of attribute type.
  #
  # source://celluloid//lib/celluloid/system_events.rb#66
  def type; end
end

# Actors communicate with asynchronous messages. Messages are buffered in
# Mailboxes until Actors can act upon them.
#
# source://celluloid//lib/celluloid/mailbox.rb#9
class Celluloid::Mailbox
  include ::Enumerable

  # @return [Mailbox] a new instance of Mailbox
  #
  # source://celluloid//lib/celluloid/mailbox.rb#16
  def initialize; end

  # Add a message to the Mailbox
  #
  # source://celluloid//lib/celluloid/mailbox.rb#26
  def <<(message); end

  # A unique address at which this mailbox can be found
  #
  # source://celluloid//lib/celluloid/mailbox.rb#13
  def address; end

  # Is the mailbox alive?
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/mailbox.rb#106
  def alive?; end

  # Receive a message from the Mailbox. May return nil and may return before
  # the specified timeout.
  #
  # source://celluloid//lib/celluloid/mailbox.rb#50
  def check(timeout = T.unsafe(nil), &block); end

  # Iterate through the mailbox
  #
  # source://celluloid//lib/celluloid/mailbox.rb#116
  def each(&block); end

  # Inspect the contents of the Mailbox
  #
  # source://celluloid//lib/celluloid/mailbox.rb#121
  def inspect; end

  # Returns the value of attribute max_size.
  #
  # source://celluloid//lib/celluloid/mailbox.rb#14
  def max_size; end

  # Sets the attribute max_size
  #
  # @param value the value to set the attribute max_size to.
  #
  # source://celluloid//lib/celluloid/mailbox.rb#14
  def max_size=(_arg0); end

  # Receive a letter from the mailbox. Guaranteed to return a message. If
  # timeout is exceeded, raise a TaskTimeout.
  #
  # source://celluloid//lib/celluloid/mailbox.rb#74
  def receive(timeout = T.unsafe(nil), &block); end

  # Shut down this mailbox and clean up its contents
  #
  # source://celluloid//lib/celluloid/mailbox.rb#85
  def shutdown; end

  # Number of messages in the Mailbox
  #
  # source://celluloid//lib/celluloid/mailbox.rb#126
  def size; end

  # Cast to an array
  #
  # source://celluloid//lib/celluloid/mailbox.rb#111
  def to_a; end

  private

  # source://celluloid//lib/celluloid/mailbox.rb#149
  def dead_letter(message); end

  # source://celluloid//lib/celluloid/mailbox.rb#153
  def mailbox_full; end

  # Retrieve the next message in the mailbox
  #
  # source://celluloid//lib/celluloid/mailbox.rb#133
  def next_message; end
end

# An alternative implementation of Celluloid::Mailbox using Reactor
#
# source://celluloid//lib/celluloid/mailbox/evented.rb#4
class Celluloid::Mailbox::Evented < ::Celluloid::Mailbox
  # @return [Evented] a new instance of Evented
  #
  # source://celluloid//lib/celluloid/mailbox/evented.rb#7
  def initialize(reactor_class); end

  # Add a message to the Mailbox
  #
  # source://celluloid//lib/celluloid/mailbox/evented.rb#14
  def <<(message); end

  # Receive a message from the Mailbox
  #
  # source://celluloid//lib/celluloid/mailbox/evented.rb#42
  def check(timeout = T.unsafe(nil), &block); end

  # Obtain the next message from the mailbox that matches the given block
  #
  # source://celluloid//lib/celluloid/mailbox/evented.rb#57
  def next_message(block); end

  # Returns the value of attribute reactor.
  #
  # source://celluloid//lib/celluloid/mailbox/evented.rb#5
  def reactor; end

  # Cleanup any IO objects this Mailbox may be using
  #
  # source://celluloid//lib/celluloid/mailbox/evented.rb#67
  def shutdown; end
end

# you can't receive from the dead
#
# source://celluloid//lib/celluloid/mailbox.rb#4
class Celluloid::MailboxDead < ::Celluloid::Error; end

# raised if the mailbox can no longer be used
#
# source://celluloid//lib/celluloid/mailbox.rb#5
class Celluloid::MailboxShutdown < ::Celluloid::Error; end

# Name an actor at the time it's registered
#
# source://celluloid//lib/celluloid/system_events.rb#85
class Celluloid::NamingRequest < ::Celluloid::SystemEvent
  # @return [NamingRequest] a new instance of NamingRequest
  #
  # source://celluloid//lib/celluloid/system_events.rb#93
  def initialize(name); end

  # Returns the value of attribute name.
  #
  # source://celluloid//lib/celluloid/system_events.rb#86
  def name; end
end

# source://celluloid//lib/celluloid/exceptions.rb#6
class Celluloid::NotActive < ::Celluloid::Error; end

# Don't do Actor-like things outside Actor scope
#
# source://celluloid//lib/celluloid/exceptions.rb#7
class Celluloid::NotActorError < ::Celluloid::Error; end

# Asked to do task-related things outside a task
#
# source://celluloid//lib/celluloid/exceptions.rb#9
class Celluloid::NotTaskError < ::Celluloid::Error; end

# source://celluloid//lib/celluloid/notices.rb#2
module Celluloid::Notices
  class << self
    # source://celluloid//lib/celluloid/notices.rb#6
    def backported; end

    # source://celluloid//lib/celluloid/notices.rb#10
    def output; end
  end
end

# reference to owning actor
#
# source://celluloid//lib/celluloid/cell.rb#2
Celluloid::OWNER_IVAR = T.let(T.unsafe(nil), Symbol)

# source://celluloid//lib/celluloid/proxies.rb#2
module Celluloid::Proxy
  class << self
    # Looks up the actual class of instance, even if instance is a proxy.
    #
    # source://celluloid//lib/celluloid/proxy/abstract.rb#3
    def class_of(instance); end
  end
end

# Base class of Celluloid proxies
#
# source://celluloid//lib/celluloid/proxy/abstract.rb#10
class Celluloid::Proxy::Abstract < ::BasicObject
  include ::Kernel
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate

  # source://celluloid//lib/celluloid/proxy/abstract.rb#22
  def __class__; end
end

# source://celluloid//lib/celluloid/proxy/abstract.rb#27
class Celluloid::Proxy::AbstractCall < ::Celluloid::Proxy::Abstract
  # @return [AbstractCall] a new instance of AbstractCall
  #
  # source://celluloid//lib/celluloid/proxy/abstract.rb#30
  def initialize(mailbox, klass); end

  # source://celluloid//lib/celluloid/proxy/abstract.rb#43
  def __klass__; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/proxy/abstract.rb#35
  def eql?(other); end

  # source://celluloid//lib/celluloid/proxy/abstract.rb#39
  def hash; end

  # source://celluloid//lib/celluloid/proxy/abstract.rb#47
  def inspect; end

  # Returns the value of attribute mailbox.
  #
  # source://celluloid//lib/celluloid/proxy/abstract.rb#28
  def mailbox; end
end

# A proxy which controls the Actor lifecycle
#
# source://celluloid//lib/celluloid/proxy/actor.rb#2
class Celluloid::Proxy::Actor < ::Celluloid::Proxy::Abstract
  # @return [Actor] a new instance of Actor
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#5
  def initialize(mailbox, thread); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#17
  def alive?; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#21
  def dead?; end

  # source://celluloid//lib/celluloid/proxy/actor.rb#10
  def inspect; end

  # Returns the value of attribute mailbox.
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#3
  def mailbox; end

  # Terminate the associated actor
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#26
  def terminate; end

  # Terminate the associated actor asynchronously
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#33
  def terminate!; end

  # Returns the value of attribute thread.
  #
  # source://celluloid//lib/celluloid/proxy/actor.rb#3
  def thread; end
end

# A proxy which sends asynchronous calls to an actor
#
# source://celluloid//lib/celluloid/proxy/async.rb#2
class Celluloid::Proxy::Async < ::Celluloid::Proxy::AbstractCall
  # source://celluloid//lib/celluloid/proxy/async.rb#3
  def method_missing(meth, *args, &block); end
end

# source://celluloid//lib/celluloid/proxy/block.rb#1
class Celluloid::Proxy::Block
  # @return [Block] a new instance of Block
  #
  # source://celluloid//lib/celluloid/proxy/block.rb#5
  def initialize(mailbox, call, block); end

  # Returns the value of attribute block.
  #
  # source://celluloid//lib/celluloid/proxy/block.rb#3
  def block; end

  # Returns the value of attribute call.
  #
  # source://celluloid//lib/celluloid/proxy/block.rb#3
  def call; end

  # Sets the attribute execution
  #
  # @param value the value to set the attribute execution to.
  #
  # source://celluloid//lib/celluloid/proxy/block.rb#2
  def execution=(_arg0); end

  # source://celluloid//lib/celluloid/proxy/block.rb#12
  def to_proc; end
end

# A proxy object returned from Celluloid::Actor.new/new_link which converts
# the normal Ruby method protocol into an inter-actor message protocol
#
# source://celluloid//lib/celluloid/proxy/cell.rb#3
class Celluloid::Proxy::Cell < ::Celluloid::Proxy::Sync
  # @return [Cell] a new instance of Cell
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#4
  def initialize(mailbox, actor_proxy, klass); end

  # source://celluloid//lib/celluloid/proxy/cell.rb#11
  def _send_(meth, *args, &block); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#45
  def alive?; end

  # Obtain an async proxy or explicitly invoke a named async method
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#28
  def async(method_name = T.unsafe(nil), *args, &block); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#49
  def dead?; end

  # Obtain a future proxy or explicitly invoke a named future method
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#37
  def future(method_name = T.unsafe(nil), *args, &block); end

  # source://celluloid//lib/celluloid/proxy/cell.rb#15
  def inspect; end

  # source://celluloid//lib/celluloid/proxy/cell.rb#21
  def method(name); end

  # source://celluloid//lib/celluloid/proxy/sync.rb#7
  def sync(meth, *args, &block); end

  # Terminate the associated actor
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#58
  def terminate; end

  # Terminate the associated actor asynchronously
  #
  # source://celluloid//lib/celluloid/proxy/cell.rb#63
  def terminate!; end

  # source://celluloid//lib/celluloid/proxy/cell.rb#53
  def thread; end
end

# A proxy which creates future calls to an actor
#
# source://celluloid//lib/celluloid/proxy/future.rb#2
class Celluloid::Proxy::Future < ::Celluloid::Proxy::AbstractCall
  # source://celluloid//lib/celluloid/proxy/future.rb#3
  def method_missing(meth, *args, &block); end
end

# A proxy which sends synchronous calls to an actor
#
# source://celluloid//lib/celluloid/proxy/sync.rb#2
class Celluloid::Proxy::Sync < ::Celluloid::Proxy::AbstractCall
  # source://celluloid//lib/celluloid/proxy/sync.rb#7
  def method_missing(meth, *args, &block); end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/proxy/sync.rb#3
  def respond_to?(meth, include_private = T.unsafe(nil)); end
end

# Signal a condition
#
# source://celluloid//lib/celluloid/system_events.rb#106
class Celluloid::SignalConditionRequest < ::Celluloid::SystemEvent
  # @return [SignalConditionRequest] a new instance of SignalConditionRequest
  #
  # source://celluloid//lib/celluloid/system_events.rb#107
  def initialize(task, value); end

  # source://celluloid//lib/celluloid/system_events.rb#117
  def call; end

  # Returns the value of attribute task.
  #
  # source://celluloid//lib/celluloid/system_events.rb#111
  def task; end

  # Returns the value of attribute value.
  #
  # source://celluloid//lib/celluloid/system_events.rb#111
  def value; end
end

# source://celluloid//lib/celluloid/exceptions.rb#5
class Celluloid::StillActive < ::Celluloid::Error; end

# source://celluloid//lib/celluloid/deprecate.rb#13
Celluloid::SyncCall = Celluloid::Call::Sync

# High-priority internal system events
#
# source://celluloid//lib/celluloid/system_events.rb#13
class Celluloid::SystemEvent
  class << self
    # source://celluloid//lib/celluloid/system_events.rb#16
    def handle(type); end

    # source://celluloid//lib/celluloid/system_events.rb#20
    def handler(&block); end
  end
end

# source://celluloid//lib/celluloid/system_events.rb#37
class Celluloid::SystemEvent::LinkingEvent < ::Celluloid::SystemEvent
  # Shared initializer for LinkingRequest and LinkingResponse
  #
  # @return [LinkingEvent] a new instance of LinkingEvent
  #
  # source://celluloid//lib/celluloid/system_events.rb#38
  def initialize(actor, type); end
end

# Tasks are interruptable/resumable execution contexts used to run methods
#
# source://celluloid//lib/celluloid/task.rb#3
class Celluloid::Task
  # Create a new task
  #
  # @return [Task] a new instance of Task
  #
  # source://celluloid//lib/celluloid/task.rb#18
  def initialize(type, meta); end

  # source://celluloid//lib/celluloid/task.rb#128
  def backtrace; end

  # Returns the value of attribute chain_id.
  #
  # source://celluloid//lib/celluloid/task.rb#15
  def chain_id; end

  # Sets the attribute chain_id
  #
  # @param value the value to set the attribute chain_id to.
  #
  # source://celluloid//lib/celluloid/task.rb#15
  def chain_id=(_arg0); end

  # source://celluloid//lib/celluloid/task.rb#55
  def create(&_block); end

  # Execute a code block in exclusive mode.
  #
  # source://celluloid//lib/celluloid/task.rb#91
  def exclusive; end

  # Is this task running in exclusive mode?
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/task.rb#124
  def exclusive?; end

  # source://celluloid//lib/celluloid/task.rb#141
  def guard(message); end

  # Returns the value of attribute guard_warnings.
  #
  # source://celluloid//lib/celluloid/task.rb#15
  def guard_warnings; end

  # Sets the attribute guard_warnings
  #
  # @param value the value to set the attribute guard_warnings to.
  #
  # source://celluloid//lib/celluloid/task.rb#15
  def guard_warnings=(_arg0); end

  # Nicer string inspect for tasks
  #
  # source://celluloid//lib/celluloid/task.rb#137
  def inspect; end

  # Returns the value of attribute meta.
  #
  # source://celluloid//lib/celluloid/task.rb#14
  def meta; end

  # Resume a suspended task, giving it a value to return if needed
  #
  # source://celluloid//lib/celluloid/task.rb#80
  def resume(value = T.unsafe(nil)); end

  # Is the current task still running?
  #
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/task.rb#132
  def running?; end

  # Returns the value of attribute status.
  #
  # source://celluloid//lib/celluloid/task.rb#14
  def status; end

  # Suspend the current task, changing the status to the given argument
  #
  # source://celluloid//lib/celluloid/task.rb#60
  def suspend(status); end

  # Terminate this task
  #
  # source://celluloid//lib/celluloid/task.rb#105
  def terminate; end

  # Returns the value of attribute type.
  #
  # source://celluloid//lib/celluloid/task.rb#14
  def type; end

  private

  # source://celluloid//lib/celluloid/task.rb#151
  def name_current_thread(new_name); end

  # source://celluloid//lib/celluloid/task.rb#162
  def thread_metadata; end

  class << self
    # Obtain the current task
    #
    # source://celluloid//lib/celluloid/task.rb#5
    def current; end

    # Suspend the running task, deferring to the scheduler
    #
    # source://celluloid//lib/celluloid/task.rb#10
    def suspend(status); end
  end
end

# Tasks with a Fiber backend
#
# source://celluloid//lib/celluloid/task/fibered.rb#4
class Celluloid::Task::Fibered < ::Celluloid::Task
  # source://celluloid//lib/celluloid/task/fibered.rb#40
  def backtrace; end

  # source://celluloid//lib/celluloid/task/fibered.rb#6
  def create; end

  # Resume a suspended task, giving it a value to return if needed
  #
  # source://celluloid//lib/celluloid/task/fibered.rb#25
  def deliver(value); end

  # source://celluloid//lib/celluloid/task/fibered.rb#20
  def signal; end

  # Terminate this task
  #
  # source://celluloid//lib/celluloid/task/fibered.rb#34
  def terminate; end
end

# source://celluloid//lib/celluloid/task/fibered.rb#5
class Celluloid::Task::Fibered::StackError < ::Celluloid::Error; end

# source://celluloid//lib/celluloid/deprecate.rb#19
Celluloid::Task::TerminatedError = Celluloid::TaskTerminated

# Tasks with a Thread backend
#
# source://celluloid//lib/celluloid/task/threaded.rb#5
class Celluloid::Task::Threaded < ::Celluloid::Task
  # Run the given block within a task
  #
  # @return [Threaded] a new instance of Threaded
  #
  # source://celluloid//lib/celluloid/task/threaded.rb#6
  def initialize(type, meta); end

  # source://celluloid//lib/celluloid/task/threaded.rb#54
  def backtrace; end

  # source://celluloid//lib/celluloid/task/threaded.rb#16
  def create; end

  # source://celluloid//lib/celluloid/task/threaded.rb#42
  def deliver(value); end

  # source://celluloid//lib/celluloid/task/threaded.rb#35
  def signal; end
end

# source://celluloid//lib/celluloid/deprecate.rb#20
Celluloid::Task::TimeoutError = Celluloid::TaskTimeout

# source://celluloid//lib/celluloid/deprecate.rb#17
Celluloid::TaskFiber = Celluloid::Task::Fibered

# Kill a running task after terminate
#
# source://celluloid//lib/celluloid/exceptions.rb#11
class Celluloid::TaskTerminated < ::Celluloid::Interruption; end

# source://celluloid//lib/celluloid/deprecate.rb#16
Celluloid::TaskThread = Celluloid::Task::Threaded

# A timeout occured before the given request could complete
#
# source://celluloid//lib/celluloid/exceptions.rb#12
class Celluloid::TaskTimeout < ::Celluloid::TimedOut; end

# Request for an actor to terminate
#
# source://celluloid//lib/celluloid/system_events.rb#99
class Celluloid::TerminationRequest < ::Celluloid::SystemEvent; end

# source://celluloid//lib/celluloid/thread.rb#4
class Celluloid::Thread < ::Thread
  # source://celluloid//lib/celluloid/thread.rb#40
  def <<(proc); end

  # Obtain the Celluloid::Actor object for this thread
  #
  # source://celluloid//lib/celluloid/thread.rb#21
  def actor; end

  # Returns the value of attribute busy.
  #
  # source://celluloid//lib/celluloid/thread.rb#9
  def busy; end

  # Sets the attribute busy
  #
  # @param value the value to set the attribute busy to.
  #
  # source://celluloid//lib/celluloid/thread.rb#9
  def busy=(_arg0); end

  # Obtain the call chain ID for this thread
  #
  # source://celluloid//lib/celluloid/thread.rb#36
  def call_chain_id; end

  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/thread.rb#5
  def celluloid?; end

  # Obtain the Celluloid mailbox for this thread
  #
  # source://celluloid//lib/celluloid/thread.rb#31
  def mailbox; end

  # Obtain the role of this thread
  #
  # source://celluloid//lib/celluloid/thread.rb#12
  def role; end

  # source://celluloid//lib/celluloid/thread.rb#16
  def role=(role); end

  # Obtain the Celluloid task object for this thread
  #
  # source://celluloid//lib/celluloid/thread.rb#26
  def task; end
end

# source://celluloid//lib/celluloid/exceptions.rb#21
class Celluloid::ThreadLeak < ::Celluloid::Error; end

# Distinguished from `Timeout`
#
# source://celluloid//lib/celluloid/exceptions.rb#4
class Celluloid::TimedOut < ::Celluloid::Interruption; end

# source://celluloid//lib/celluloid/version.rb#2
Celluloid::VERSION = T.let(T.unsafe(nil), String)

# source://celluloid//lib/celluloid/core_ext.rb#3
class Thread
  # @return [Boolean]
  #
  # source://celluloid//lib/celluloid/core_ext.rb#6
  def celluloid?; end

  # Returns the value of attribute uuid_counter.
  #
  # source://celluloid//lib/celluloid/core_ext.rb#4
  def uuid_counter; end

  # Sets the attribute uuid_counter
  #
  # @param value the value to set the attribute uuid_counter to.
  #
  # source://celluloid//lib/celluloid/core_ext.rb#4
  def uuid_counter=(_arg0); end

  # Returns the value of attribute uuid_limit.
  #
  # source://celluloid//lib/celluloid/core_ext.rb#4
  def uuid_limit; end

  # Sets the attribute uuid_limit
  #
  # @param value the value to set the attribute uuid_limit to.
  #
  # source://celluloid//lib/celluloid/core_ext.rb#4
  def uuid_limit=(_arg0); end

  class << self
    # source://celluloid//lib/celluloid/deprecate.rb#2
    def mailbox; end

    # source://celluloid//lib/celluloid/deprecate.rb#6
    def receive(timeout = T.unsafe(nil), &block); end
  end
end
