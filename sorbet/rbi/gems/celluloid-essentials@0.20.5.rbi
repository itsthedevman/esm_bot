# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `celluloid-essentials` gem.
# Please instead update this file by running `bin/tapioca gem celluloid-essentials`.

# source://celluloid-essentials//lib/celluloid/internals/call_chain.rb#1
module Celluloid
  include ::Celluloid::InstanceMethods

  mixes_in_class_methods ::Celluloid::ClassMethods
  mixes_in_class_methods ::Celluloid::Internals::Properties

  # source://forwardable/1.3.1/forwardable.rb#226
  def [](*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def []=(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#317
  def abort(cause); end

  # source://celluloid/0.17.4/lib/celluloid.rb#431
  def after(interval, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#450
  def async(meth = T.unsafe(nil), *args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#347
  def call_chain_id; end

  # source://celluloid/0.17.4/lib/celluloid.rb#342
  def current_actor; end

  # source://celluloid/0.17.4/lib/celluloid.rb#443
  def defer(&block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#436
  def every(interval, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#420
  def exclusive(&block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#425
  def exclusive?; end

  # source://celluloid/0.17.4/lib/celluloid.rb#455
  def future(meth = T.unsafe(nil), *args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#372
  def link(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#387
  def linked_to?(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#357
  def links; end

  # source://celluloid/0.17.4/lib/celluloid.rb#362
  def monitor(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#382
  def monitoring?(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#392
  def receive(timeout = T.unsafe(nil), &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#81
  def services; end

  # source://celluloid/0.17.4/lib/celluloid.rb#332
  def signal(name, value = T.unsafe(nil)); end

  # source://celluloid/0.17.4/lib/celluloid.rb#402
  def sleep(interval); end

  # source://celluloid/0.17.4/lib/celluloid.rb#352
  def tasks; end

  # source://celluloid/0.17.4/lib/celluloid.rb#327
  def terminate; end

  # source://celluloid/0.17.4/lib/celluloid.rb#412
  def timeout(duration); end

  # source://celluloid/0.17.4/lib/celluloid.rb#377
  def unlink(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#367
  def unmonitor(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#337
  def wait(name); end

  class << self
    # source://celluloid/0.17.4/lib/celluloid.rb#81
    def actor?; end

    # source://celluloid/0.17.4/lib/celluloid.rb#34
    def actor_system; end

    # source://celluloid/0.17.4/lib/celluloid.rb#27
    def actor_system=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#145
    def boot; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def cores; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def cpus; end

    # source://celluloid/0.17.4/lib/celluloid.rb#119
    def detect_recursion; end

    # source://celluloid/0.17.4/lib/celluloid.rb#103
    def dump(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#131
    def exception_handler(&block); end

    # source://celluloid/0.17.4/lib/celluloid.rb#30
    def group_class; end

    # source://celluloid/0.17.4/lib/celluloid.rb#30
    def group_class=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#42
    def included(klass); end

    # source://celluloid/0.17.4/lib/celluloid.rb#150
    def init; end

    # source://celluloid/0.17.4/lib/celluloid.rb#29
    def log_actor_crashes; end

    # source://celluloid/0.17.4/lib/celluloid.rb#29
    def log_actor_crashes=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#28
    def logger; end

    # source://celluloid/0.17.4/lib/celluloid.rb#28
    def logger=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#86
    def mailbox; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def ncpus; end

    # source://celluloid/0.17.4/lib/celluloid.rb#114
    def public_registry; end

    # source://celluloid-essentials//lib/celluloid/notifications.rb#92
    def publish(*args); end

    # source://celluloid/0.17.4/lib/celluloid.rb#162
    def register_shutdown; end

    # source://celluloid/0.17.4/lib/celluloid.rb#158
    def running?; end

    # source://celluloid/0.17.4/lib/celluloid.rb#183
    def shutdown; end

    # source://celluloid/0.17.4/lib/celluloid.rb#32
    def shutdown_timeout; end

    # source://celluloid/0.17.4/lib/celluloid.rb#32
    def shutdown_timeout=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#103
    def stack_dump(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#109
    def stack_summary(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#154
    def start; end

    # source://celluloid/0.17.4/lib/celluloid.rb#109
    def summarize(output = T.unsafe(nil)); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#5
    def supervise(*args, &block); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#10
    def supervise_as(name, *args, &block); end

    # source://celluloid/0.17.4/lib/celluloid.rb#135
    def suspend(status, waiter); end

    # source://celluloid/0.17.4/lib/celluloid.rb#31
    def task_class; end

    # source://celluloid/0.17.4/lib/celluloid.rb#31
    def task_class=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#91
    def uuid; end

    # source://celluloid/0.17.4/lib/celluloid.rb#187
    def version; end
  end
end

# source://celluloid-essentials//lib/celluloid/essentials.rb#29
Celluloid::CPUCounter = Celluloid::Internals::CPUCounter

# Wraps all events and context for a single incident.
#
# source://celluloid-essentials//lib/celluloid/logging/incident.rb#3
class Celluloid::Incident
  # @return [Incident] a new instance of Incident
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#7
  def initialize(events, triggering_event = T.unsafe(nil)); end

  # Returns the value of attribute events.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#5
  def events; end

  # Sets the attribute events
  #
  # @param value the value to set the attribute events to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#5
  def events=(_arg0); end

  # Merge two incidents together. This may be useful if two incidents occur at the same time.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#14
  def merge(*other_incidents); end

  # Returns the value of attribute pid.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#4
  def pid; end

  # Sets the attribute pid
  #
  # @param value the value to set the attribute pid to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#4
  def pid=(_arg0); end

  # Returns the value of attribute triggering_event.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#5
  def triggering_event; end

  # Sets the attribute triggering_event
  #
  # @param value the value to set the attribute triggering_event to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident.rb#5
  def triggering_event=(_arg0); end
end

# A logger that holds all messages in circular buffers, then flushes the buffers
# when an event occurs at a configurable severity threshold.
#
# Unlike ruby's Logger, this class only supports a single progname.
#
# source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#7
class Celluloid::IncidentLogger
  include ::Logger::Severity
  include ::Celluloid::IncidentLogger::Severity

  # Create a new IncidentLogger.
  #
  # @return [IncidentLogger] a new instance of IncidentLogger
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#44
  def initialize(progname = T.unsafe(nil), options = T.unsafe(nil)); end

  # add an event.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#65
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # Returns the value of attribute buffers.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#41
  def buffers; end

  # Sets the attribute buffers
  #
  # @param value the value to set the attribute buffers to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#41
  def buffers=(_arg0); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#132
  def clear; end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#138
  def create_incident(event = T.unsafe(nil)); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#96
  def debug(progname = T.unsafe(nil), &block); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#108
  def error(progname = T.unsafe(nil), &block); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#112
  def fatal(progname = T.unsafe(nil), &block); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#120
  def flush; end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#142
  def incident_topic; end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#100
  def info(progname = T.unsafe(nil), &block); end

  # The logging level. Messages below this severity will not be logged at all.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#31
  def level; end

  # The logging level. Messages below this severity will not be logged at all.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#31
  def level=(_arg0); end

  # add an event.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#65
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # The progname (facility) for this instance.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#28
  def progname; end

  # The progname (facility) for this instance.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#28
  def progname=(_arg0); end

  # The buffer size limit. Each log level will retain this number of messages
  # at maximum.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#39
  def sizelimit; end

  # The buffer size limit. Each log level will retain this number of messages
  # at maximum.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#39
  def sizelimit=(_arg0); end

  # The incident threshold. Messages at or above this severity will generate an
  # incident and be published to incident reporters.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#35
  def threshold; end

  # The incident threshold. Messages at or above this severity will generate an
  # incident and be published to incident reporters.
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#35
  def threshold=(_arg0); end

  # See docs for Logger#info
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#92
  def trace(progname = T.unsafe(nil), &block); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#116
  def unknown(progname = T.unsafe(nil), &block); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#104
  def warn(progname = T.unsafe(nil), &block); end
end

# source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#8
module Celluloid::IncidentLogger::Severity
  include ::Logger::Severity

  # source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#13
  def severity_to_string(severity); end
end

# source://celluloid-essentials//lib/celluloid/logging/incident_logger.rb#11
Celluloid::IncidentLogger::Severity::TRACE = T.let(T.unsafe(nil), Integer)

# Subscribes to log incident topics to report on them.
#
# source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#4
class Celluloid::IncidentReporter
  include ::Celluloid
  include ::Celluloid::InstanceMethods
  include ::Celluloid::Notifications
  extend ::Celluloid::ClassMethods
  extend ::Celluloid::Internals::Properties

  # @return [IncidentReporter] a new instance of IncidentReporter
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#15
  def initialize(*args); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#22
  def report(_topic, incident); end

  # source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#36
  def silence; end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#44
  def silenced?; end

  # source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#40
  def unsilence; end

  class << self
    # source://celluloid/0.17.4/lib/celluloid.rb#71
    def exclusive(*args); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def exclusive_actor(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def exclusive_methods(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def execute_block_on_receiver(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def exit_handler_name(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def finalizer(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def group_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def mailbox_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def mailbox_size(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def proxy_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def task_class(value = T.unsafe(nil), *extra); end

    # source://celluloid/0.17.4/lib/celluloid.rb#67
    def trap_exit(*args); end
  end
end

# get the time from the event
#
# source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#9
class Celluloid::IncidentReporter::Formatter < ::Logger::Formatter
  # source://celluloid-essentials//lib/celluloid/logging/incident_reporter.rb#10
  def call(severity, _time, progname, msg); end
end

# source://celluloid-essentials//lib/celluloid/essentials.rb#1
module Celluloid::Internals; end

# source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#3
module Celluloid::Internals::CPUCounter
  class << self
    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#5
    def cores; end

    private

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#11
    def count_cores; end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#15
    def from_env; end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#32
    def from_java; end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#37
    def from_proc; end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#54
    def from_result(result); end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#49
    def from_sysctl; end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#21
    def from_sysdev; end

    # source://celluloid-essentials//lib/celluloid/internals/cpu_counter.rb#42
    def from_win32ole; end
  end
end

# source://celluloid-essentials//lib/celluloid/internals/call_chain.rb#3
class Celluloid::Internals::CallChain
  class << self
    # source://celluloid-essentials//lib/celluloid/internals/call_chain.rb#10
    def current_id; end

    # source://celluloid-essentials//lib/celluloid/internals/call_chain.rb#4
    def current_id=(value); end
  end
end

# Methods blocking on a call to receive
#
# source://celluloid-essentials//lib/celluloid/internals/handlers.rb#26
class Celluloid::Internals::Handler
  # @return [Handler] a new instance of Handler
  #
  # source://celluloid-essentials//lib/celluloid/internals/handlers.rb#27
  def initialize(pattern, block); end

  # source://celluloid-essentials//lib/celluloid/internals/handlers.rb#37
  def call(message); end

  # Match a message with this receiver's block
  #
  # source://celluloid-essentials//lib/celluloid/internals/handlers.rb#33
  def match(message); end
end

# source://celluloid-essentials//lib/celluloid/internals/handlers.rb#5
class Celluloid::Internals::Handlers
  # @return [Handlers] a new instance of Handlers
  #
  # source://celluloid-essentials//lib/celluloid/internals/handlers.rb#6
  def initialize; end

  # source://celluloid-essentials//lib/celluloid/internals/handlers.rb#10
  def handle(*patterns, &block); end

  # Handle incoming messages
  #
  # source://celluloid-essentials//lib/celluloid/internals/handlers.rb#18
  def handle_message(message); end
end

# Linked actors send each other system events
#
# source://celluloid-essentials//lib/celluloid/internals/links.rb#4
class Celluloid::Internals::Links
  include ::Enumerable

  # @return [Links] a new instance of Links
  #
  # source://celluloid-essentials//lib/celluloid/internals/links.rb#7
  def initialize; end

  # Add an actor to the current links
  #
  # source://celluloid-essentials//lib/celluloid/internals/links.rb#12
  def <<(actor); end

  # Remove an actor from the links
  #
  # source://celluloid-essentials//lib/celluloid/internals/links.rb#22
  def delete(actor); end

  # Iterate through all links
  #
  # source://celluloid-essentials//lib/celluloid/internals/links.rb#27
  def each; end

  # Do links include the given actor?
  #
  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/internals/links.rb#17
  def include?(actor); end

  # Generate a string representation
  #
  # source://celluloid-essentials//lib/celluloid/internals/links.rb#32
  def inspect; end
end

# source://celluloid-essentials//lib/celluloid/internals/logger.rb#3
module Celluloid::Internals::Logger
  private

  # Handle a crash
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#59
  def crash(string, exception); end

  # Send a debug message
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#39
  def debug(string); end

  # Note a deprecation
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#75
  def deprecate(message); end

  # Send an error message
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#54
  def error(string); end

  # Define an exception handler
  # NOTE: These should be defined at application start time
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#82
  def exception_handler(&block); end

  # Format an exception message
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#88
  def format_exception(exception); end

  # Send a info message
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#44
  def info(string); end

  # Send a warning message
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#49
  def warn(string); end

  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#34
  def with_backtrace(backtrace); end

  class << self
    # Handle a crash
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#59
    def crash(string, exception); end

    # Send a debug message
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#39
    def debug(string); end

    # Note a deprecation
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#75
    def deprecate(message); end

    # Send an error message
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#54
    def error(string); end

    # Define an exception handler
    # NOTE: These should be defined at application start time
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#82
    def exception_handler(&block); end

    # Format an exception message
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#88
    def format_exception(exception); end

    # Send a info message
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#44
    def info(string); end

    # Send a warning message
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#49
    def warn(string); end

    # @yield [WithBacktrace.new(backtrace)]
    #
    # source://celluloid-essentials//lib/celluloid/internals/logger.rb#34
    def with_backtrace(backtrace); end
  end
end

# source://celluloid-essentials//lib/celluloid/internals/logger.rb#4
class Celluloid::Internals::Logger::WithBacktrace
  # @return [WithBacktrace] a new instance of WithBacktrace
  #
  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#5
  def initialize(backtrace); end

  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#9
  def debug(string); end

  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#25
  def decorate(string); end

  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#21
  def error(string); end

  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#13
  def info(string); end

  # source://celluloid-essentials//lib/celluloid/internals/logger.rb#17
  def warn(string); end
end

# Method handles that route through an actor proxy
#
# source://celluloid-essentials//lib/celluloid/internals/method.rb#4
class Celluloid::Internals::Method
  # @return [Method] a new instance of Method
  #
  # source://celluloid-essentials//lib/celluloid/internals/method.rb#5
  def initialize(proxy, name); end

  # source://celluloid-essentials//lib/celluloid/internals/method.rb#12
  def arity; end

  # source://celluloid-essentials//lib/celluloid/internals/method.rb#24
  def call(*args, &block); end

  # source://celluloid-essentials//lib/celluloid/internals/method.rb#28
  def inspect; end

  # source://celluloid-essentials//lib/celluloid/internals/method.rb#16
  def name; end

  # source://celluloid-essentials//lib/celluloid/internals/method.rb#20
  def parameters; end
end

# Properties define inheritable attributes of classes, somewhat similar to
# Rails cattr_*/mattr_* or class_attribute
#
# source://celluloid-essentials//lib/celluloid/internals/properties.rb#5
module Celluloid::Internals::Properties
  # source://celluloid-essentials//lib/celluloid/internals/properties.rb#6
  def property(name, opts = T.unsafe(nil)); end
end

# Methods blocking on a call to receive
#
# source://celluloid-essentials//lib/celluloid/internals/receivers.rb#45
class Celluloid::Internals::Receiver
  # @return [Receiver] a new instance of Receiver
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#48
  def initialize(block); end

  # Match a message with this receiver's block
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#55
  def match(message); end

  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#59
  def resume(message = T.unsafe(nil)); end

  # Returns the value of attribute timer.
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#46
  def timer; end

  # Sets the attribute timer
  #
  # @param value the value to set the attribute timer to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#46
  def timer=(_arg0); end
end

# Allow methods to directly interact with the actor protocol
#
# source://celluloid-essentials//lib/celluloid/internals/receivers.rb#7
class Celluloid::Internals::Receivers
  # @return [Receivers] a new instance of Receivers
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#8
  def initialize(timers); end

  # Handle incoming messages
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#33
  def handle_message(message); end

  # Receive an asynchronous message
  #
  # source://celluloid-essentials//lib/celluloid/internals/receivers.rb#14
  def receive(timeout = T.unsafe(nil), &block); end
end

# The Registry allows us to refer to specific actors by human-meaningful names
#
# source://celluloid-essentials//lib/celluloid/internals/registry.rb#6
class Celluloid::Internals::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#7
  def initialize; end

  # Retrieve an actor by name
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#53
  def [](name); end

  # Register an Actor
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#16
  def []=(name, actor); end

  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#37
  def add(name, actor, branch = T.unsafe(nil)); end

  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#60
  def branch(name); end

  # removes and returns all registered actors as a hash of `name => actor`
  # can be used in testing to clear the registry
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#91
  def clear; end

  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#69
  def delete(name); end

  # Retrieve an actor by name
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#53
  def get(name); end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#76
  def include?(name); end

  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#85
  def index; end

  # List all registered actors by name
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#81
  def names; end

  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#44
  def root; end

  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#44
  def services; end

  # Register an Actor
  #
  # source://celluloid-essentials//lib/celluloid/internals/registry.rb#16
  def set(name, actor); end
end

# Responses to calls
#
# source://celluloid-essentials//lib/celluloid/internals/responses.rb#4
class Celluloid::Internals::Response
  # @return [Response] a new instance of Response
  #
  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#7
  def initialize(call, value); end

  # Returns the value of attribute call.
  #
  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#5
  def call; end

  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#11
  def dispatch; end

  # Returns the value of attribute value.
  #
  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#5
  def value; end
end

# source://celluloid-essentials//lib/celluloid/internals/responses.rb#33
class Celluloid::Internals::Response::Block
  # @return [Block] a new instance of Block
  #
  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#34
  def initialize(call, result); end

  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#39
  def dispatch; end
end

# Call was aborted due to sender error
#
# source://celluloid-essentials//lib/celluloid/internals/responses.rb#19
class Celluloid::Internals::Response::Error < ::Celluloid::Internals::Response
  # source://celluloid-essentials//lib/celluloid/internals/responses.rb#20
  def value; end
end

# Call completed successfully
#
# source://celluloid-essentials//lib/celluloid/internals/responses.rb#16
class Celluloid::Internals::Response::Success < ::Celluloid::Internals::Response; end

# Event signaling between methods of the same object
#
# source://celluloid-essentials//lib/celluloid/internals/signals.rb#4
class Celluloid::Internals::Signals
  # @return [Signals] a new instance of Signals
  #
  # source://celluloid-essentials//lib/celluloid/internals/signals.rb#5
  def initialize; end

  # Send a signal to all method calls waiting for the given name
  #
  # source://celluloid-essentials//lib/celluloid/internals/signals.rb#18
  def broadcast(name, value = T.unsafe(nil)); end

  # Wait for the given signal and return the associated value
  #
  # source://celluloid-essentials//lib/celluloid/internals/signals.rb#10
  def wait(name); end
end

# source://celluloid-essentials//lib/celluloid/internals/stack.rb#3
class Celluloid::Internals::Stack
  # @return [Stack] a new instance of Stack
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#6
  def initialize(threads); end

  # Returns the value of attribute actors.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#4
  def actors; end

  # Sets the attribute actors
  #
  # @param value the value to set the attribute actors to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#4
  def actors=(_arg0); end

  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#57
  def print(output = T.unsafe(nil)); end

  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#12
  def snapshot(backtrace = T.unsafe(nil)); end

  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#22
  def snapshot_actor(actor, backtrace = T.unsafe(nil)); end

  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#41
  def snapshot_cell(behavior); end

  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#48
  def snapshot_thread(thread, backtrace = T.unsafe(nil)); end

  # Returns the value of attribute threads.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#4
  def threads; end

  # Sets the attribute threads
  #
  # @param value the value to set the attribute threads to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack.rb#4
  def threads=(_arg0); end
end

# source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#33
class Celluloid::Internals::Stack::ActorState
  include ::Celluloid::Internals::Stack::DisplayBacktrace

  # Returns the value of attribute backtrace.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#37
  def backtrace; end

  # Sets the attribute backtrace
  #
  # @param value the value to set the attribute backtrace to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#37
  def backtrace=(_arg0); end

  # Returns the value of attribute cell.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#35
  def cell; end

  # Sets the attribute cell
  #
  # @param value the value to set the attribute cell to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#35
  def cell=(_arg0); end

  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#39
  def dump; end

  # Returns the value of attribute id.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#35
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#35
  def id=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#35
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#35
  def name=(_arg0); end

  # Returns the value of attribute status.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#36
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#36
  def status=(_arg0); end

  # Returns the value of attribute tasks.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#36
  def tasks; end

  # Sets the attribute tasks
  #
  # @param value the value to set the attribute tasks to.
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#36
  def tasks=(_arg0); end
end

# source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#17
class Celluloid::Internals::Stack::CellState < ::Struct
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#18
  def dump; end
end

# source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#4
module Celluloid::Internals::Stack::DisplayBacktrace
  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#5
  def display_backtrace(backtrace, output, indent = T.unsafe(nil)); end
end

# source://celluloid-essentials//lib/celluloid/internals/stack/dump.rb#4
class Celluloid::Internals::Stack::Dump < ::Celluloid::Internals::Stack
  # @return [Dump] a new instance of Dump
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/dump.rb#5
  def initialize(threads); end
end

# source://celluloid-essentials//lib/celluloid/internals/stack/summary.rb#4
class Celluloid::Internals::Stack::Summary < ::Celluloid::Internals::Stack
  # @return [Summary] a new instance of Summary
  #
  # source://celluloid-essentials//lib/celluloid/internals/stack/summary.rb#5
  def initialize(threads); end
end

# source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#15
class Celluloid::Internals::Stack::TaskState < ::Struct; end

# source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#23
class Celluloid::Internals::Stack::ThreadState < ::Struct
  include ::Celluloid::Internals::Stack::DisplayBacktrace

  # source://celluloid-essentials//lib/celluloid/internals/stack/states.rb#25
  def dump; end
end

# source://celluloid-essentials//lib/celluloid/internals/task_set.rb#48
Celluloid::Internals::TaskSet = Set

# An abstraction around threads from the InternalPool which ensures we don't
# accidentally do things to threads which have been returned to the pool,
# such as, say, killing them
#
# source://celluloid-essentials//lib/celluloid/internals/thread_handle.rb#6
class Celluloid::Internals::ThreadHandle
  # @return [ThreadHandle] a new instance of ThreadHandle
  #
  # source://celluloid-essentials//lib/celluloid/internals/thread_handle.rb#7
  def initialize(actor_system, role = T.unsafe(nil)); end

  # Is the thread running?
  #
  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/internals/thread_handle.rb#25
  def alive?; end

  # Obtain the backtrace for this thread
  #
  # source://celluloid-essentials//lib/celluloid/internals/thread_handle.rb#43
  def backtrace; end

  # Join to a running thread, blocking until it terminates
  #
  # source://celluloid-essentials//lib/celluloid/internals/thread_handle.rb#36
  def join(limit = T.unsafe(nil)); end

  # Forcibly kill the thread
  #
  # source://celluloid-essentials//lib/celluloid/internals/thread_handle.rb#30
  def kill; end
end

# Clearly Ruby doesn't have enough UUID libraries
# This one aims to be fast and simple with good support for multiple threads
# If there's a better UUID library I can use with similar multithreaded
# performance, I certainly wouldn't mind using a gem for this!
#
# source://celluloid-essentials//lib/celluloid/internals/uuid.rb#9
module Celluloid::Internals::UUID
  class << self
    # source://celluloid-essentials//lib/celluloid/internals/uuid.rb#17
    def generate; end
  end
end

# source://celluloid-essentials//lib/celluloid/internals/uuid.rb#12
Celluloid::Internals::UUID::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://celluloid-essentials//lib/celluloid/internals/uuid.rb#11
Celluloid::Internals::UUID::PREFIX = T.let(T.unsafe(nil), String)

# source://celluloid-essentials//lib/celluloid/essentials.rb#26
Celluloid::Links = Celluloid::Internals::Links

# Wraps a single log event.
#
# source://celluloid-essentials//lib/celluloid/logging/log_event.rb#3
class Celluloid::LogEvent
  # @return [LogEvent] a new instance of LogEvent
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#6
  def initialize(severity, message, progname, time = T.unsafe(nil), &_block); end

  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#16
  def <=>(other); end

  # Returns the value of attribute id.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def id=(_arg0); end

  # Returns the value of attribute message.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def message=(_arg0); end

  # Returns the value of attribute progname.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def progname; end

  # Sets the attribute progname
  #
  # @param value the value to set the attribute progname to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def progname=(_arg0); end

  # Returns the value of attribute severity.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def severity; end

  # Sets the attribute severity
  #
  # @param value the value to set the attribute severity to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def severity=(_arg0); end

  # Returns the value of attribute time.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def time; end

  # Sets the attribute time
  #
  # @param value the value to set the attribute time to.
  #
  # source://celluloid-essentials//lib/celluloid/logging/log_event.rb#4
  def time=(_arg0); end
end

# source://celluloid-essentials//lib/celluloid/essentials.rb#27
Celluloid::Logger = Celluloid::Internals::Logger

# source://celluloid-essentials//lib/celluloid/notifications.rb#2
module Celluloid::Notifications
  # source://celluloid-essentials//lib/celluloid/notifications.rb#16
  def subscribe(pattern, method); end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#20
  def unsubscribe(*args); end

  private

  # source://celluloid-essentials//lib/celluloid/notifications.rb#7
  def publish(pattern, *args); end

  class << self
    # source://celluloid-essentials//lib/celluloid/notifications.rb#3
    def notifier; end

    # source://celluloid-essentials//lib/celluloid/notifications.rb#7
    def publish(pattern, *args); end
  end
end

# source://celluloid-essentials//lib/celluloid/notifications.rb#24
class Celluloid::Notifications::Fanout
  include ::Celluloid
  include ::Celluloid::InstanceMethods
  extend ::Celluloid::ClassMethods
  extend ::Celluloid::Internals::Properties

  # @return [Fanout] a new instance of Fanout
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#28
  def initialize; end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#51
  def listeners_for(pattern); end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#55
  def listening?(pattern); end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#59
  def prune(actor, _reason = T.unsafe(nil)); end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#47
  def publish(pattern, *args); end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#33
  def subscribe(actor, pattern, method); end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#42
  def unsubscribe(subscriber); end

  class << self
    # source://celluloid/0.17.4/lib/celluloid.rb#71
    def exclusive(*args); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def exclusive_actor(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def exclusive_methods(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def execute_block_on_receiver(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def exit_handler_name(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def finalizer(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def group_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def mailbox_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def mailbox_size(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def proxy_class(value = T.unsafe(nil), *extra); end

    # source://celluloid-essentials//lib/celluloid/internals/properties.rb#13
    def task_class(value = T.unsafe(nil), *extra); end

    # source://celluloid/0.17.4/lib/celluloid.rb#67
    def trap_exit(*args); end
  end
end

# source://celluloid-essentials//lib/celluloid/notifications.rb#65
class Celluloid::Notifications::Subscriber
  # @return [Subscriber] a new instance of Subscriber
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#68
  def initialize(actor, pattern, method); end

  # Returns the value of attribute actor.
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#66
  def actor; end

  # Sets the attribute actor
  #
  # @param value the value to set the attribute actor to.
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#66
  def actor=(_arg0); end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#85
  def matches?(subscriber_or_pattern); end

  # Returns the value of attribute method.
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#66
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#66
  def method=(_arg0); end

  # Returns the value of attribute pattern.
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#66
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#66
  def pattern=(_arg0); end

  # source://celluloid-essentials//lib/celluloid/notifications.rb#74
  def publish(pattern, *args); end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/notifications.rb#81
  def subscribed_to?(pattern); end
end

# source://celluloid-essentials//lib/celluloid/essentials.rb#31
Celluloid::Properties = Celluloid::Internals::Properties

# source://celluloid-essentials//lib/celluloid/essentials.rb#28
Celluloid::Registry = Celluloid::Internals::Registry

# source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#2
class Celluloid::RingBuffer
  # @return [RingBuffer] a new instance of RingBuffer
  #
  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#3
  def initialize(size); end

  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#19
  def <<(value); end

  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#47
  def clear; end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#15
  def empty?; end

  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#39
  def flush; end

  # @return [Boolean]
  #
  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#11
  def full?; end

  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#19
  def push(value); end

  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#33
  def shift; end

  private

  # source://celluloid-essentials//lib/celluloid/logging/ring_buffer.rb#55
  def remove_element; end
end

# source://celluloid-essentials//lib/celluloid/essentials.rb#30
Celluloid::StackDump = Celluloid::Internals::Stack::Dump

# source://celluloid-essentials//lib/celluloid/essentials.rb#32
Celluloid::ThreadHandle = Celluloid::Internals::ThreadHandle

# source://celluloid-essentials//lib/celluloid/essentials.rb#25
Celluloid::UUID = Celluloid::Internals::UUID
