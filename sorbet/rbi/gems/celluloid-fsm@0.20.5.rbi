# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `celluloid-fsm` gem.
# Please instead update this file by running `bin/tapioca gem celluloid-fsm`.

# source://celluloid-fsm//lib/celluloid/fsm.rb#3
module Celluloid
  include ::Celluloid::InstanceMethods

  mixes_in_class_methods ::Celluloid::ClassMethods
  mixes_in_class_methods ::Celluloid::Internals::Properties

  # source://forwardable/1.3.1/forwardable.rb#226
  def [](*args, &block); end

  # source://forwardable/1.3.1/forwardable.rb#226
  def []=(*args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#317
  def abort(cause); end

  # source://celluloid/0.17.4/lib/celluloid.rb#431
  def after(interval, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#450
  def async(meth = T.unsafe(nil), *args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#347
  def call_chain_id; end

  # source://celluloid/0.17.4/lib/celluloid.rb#342
  def current_actor; end

  # source://celluloid/0.17.4/lib/celluloid.rb#443
  def defer(&block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#436
  def every(interval, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#420
  def exclusive(&block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#425
  def exclusive?; end

  # source://celluloid/0.17.4/lib/celluloid.rb#455
  def future(meth = T.unsafe(nil), *args, &block); end

  # source://celluloid/0.17.4/lib/celluloid.rb#372
  def link(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#387
  def linked_to?(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#357
  def links; end

  # source://celluloid/0.17.4/lib/celluloid.rb#362
  def monitor(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#382
  def monitoring?(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#392
  def receive(timeout = T.unsafe(nil), &block); end

  # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/container/instance.rb#81
  def services; end

  # source://celluloid/0.17.4/lib/celluloid.rb#332
  def signal(name, value = T.unsafe(nil)); end

  # source://celluloid/0.17.4/lib/celluloid.rb#402
  def sleep(interval); end

  # source://celluloid/0.17.4/lib/celluloid.rb#352
  def tasks; end

  # source://celluloid/0.17.4/lib/celluloid.rb#327
  def terminate; end

  # source://celluloid/0.17.4/lib/celluloid.rb#412
  def timeout(duration); end

  # source://celluloid/0.17.4/lib/celluloid.rb#377
  def unlink(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#367
  def unmonitor(actor); end

  # source://celluloid/0.17.4/lib/celluloid.rb#337
  def wait(name); end

  class << self
    # source://celluloid/0.17.4/lib/celluloid.rb#81
    def actor?; end

    # source://celluloid/0.17.4/lib/celluloid.rb#34
    def actor_system; end

    # source://celluloid/0.17.4/lib/celluloid.rb#27
    def actor_system=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#145
    def boot; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def cores; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def cpus; end

    # source://celluloid/0.17.4/lib/celluloid.rb#119
    def detect_recursion; end

    # source://celluloid/0.17.4/lib/celluloid.rb#103
    def dump(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#131
    def exception_handler(&block); end

    # source://celluloid/0.17.4/lib/celluloid.rb#30
    def group_class; end

    # source://celluloid/0.17.4/lib/celluloid.rb#30
    def group_class=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#42
    def included(klass); end

    # source://celluloid/0.17.4/lib/celluloid.rb#150
    def init; end

    # source://celluloid/0.17.4/lib/celluloid.rb#29
    def log_actor_crashes; end

    # source://celluloid/0.17.4/lib/celluloid.rb#29
    def log_actor_crashes=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#28
    def logger; end

    # source://celluloid/0.17.4/lib/celluloid.rb#28
    def logger=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#86
    def mailbox; end

    # source://celluloid/0.17.4/lib/celluloid.rb#96
    def ncpus; end

    # source://celluloid/0.17.4/lib/celluloid.rb#114
    def public_registry; end

    # source://celluloid-essentials/0.20.5/lib/celluloid/notifications.rb#92
    def publish(*args); end

    # source://celluloid/0.17.4/lib/celluloid.rb#162
    def register_shutdown; end

    # source://celluloid/0.17.4/lib/celluloid.rb#158
    def running?; end

    # source://celluloid/0.17.4/lib/celluloid.rb#183
    def shutdown; end

    # source://celluloid/0.17.4/lib/celluloid.rb#32
    def shutdown_timeout; end

    # source://celluloid/0.17.4/lib/celluloid.rb#32
    def shutdown_timeout=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#103
    def stack_dump(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#109
    def stack_summary(output = T.unsafe(nil)); end

    # source://celluloid/0.17.4/lib/celluloid.rb#154
    def start; end

    # source://celluloid/0.17.4/lib/celluloid.rb#109
    def summarize(output = T.unsafe(nil)); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#5
    def supervise(*args, &block); end

    # source://celluloid-supervision/0.20.6/lib/celluloid/supervision/deprecate/supervise.rb#10
    def supervise_as(name, *args, &block); end

    # source://celluloid/0.17.4/lib/celluloid.rb#135
    def suspend(status, waiter); end

    # source://celluloid/0.17.4/lib/celluloid.rb#31
    def task_class; end

    # source://celluloid/0.17.4/lib/celluloid.rb#31
    def task_class=(_arg0); end

    # source://celluloid/0.17.4/lib/celluloid.rb#91
    def uuid; end

    # source://celluloid/0.17.4/lib/celluloid.rb#187
    def version; end
  end
end

# Simple finite state machines with integrated Celluloid timeout support
# Inspired by Erlang's gen_fsm (http://www.erlang.org/doc/man/gen_fsm.html)
#
# Basic usage:
#
#     class MyMachine
#       include Celluloid::FSM # NOTE: this does NOT pull in the Celluloid module
#     end
#
# Inside an actor:
#
#     #
#     machine = MyMachine.new(current_actor)
#
# source://celluloid-fsm//lib/celluloid/fsm.rb#17
module Celluloid::FSM
  mixes_in_class_methods ::Celluloid::FSM::ClassMethods

  # Be kind and call super if you must redefine initialize
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#65
  def initialize(actor = T.unsafe(nil)); end

  # Returns the value of attribute actor.
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#62
  def actor; end

  # Attach this FSM to an actor. This allows FSMs to wait for and initiate
  # events in the context of a particular actor
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#77
  def actor=(actor); end

  # Attach this FSM to an actor. This allows FSMs to wait for and initiate
  # events in the context of a particular actor
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#77
  def attach(actor); end

  # Obtain the current state of the FSM
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#73
  def state; end

  # Transition to another state
  # Options:
  # * delay: don't transition immediately, wait the given number of seconds.
  #          This will return a Celluloid::Timer object you can use to
  #          cancel the pending state transition.
  #
  # Note: making additional state transitions will cancel delayed transitions
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#89
  def transition(state_name, options = T.unsafe(nil)); end

  # Immediate state transition with no sanity checks, or callbacks. "Dangerous!"
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#101
  def transition!(state_name); end

  protected

  # source://celluloid-fsm//lib/celluloid/fsm.rb#140
  def current_state; end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#144
  def current_state_name; end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#136
  def default_state; end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#148
  def handle_delayed_transitions(new_state, delay); end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#132
  def states; end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#127
  def transition_with_callbacks!(state_name); end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#107
  def validate_and_sanitize_new_state(state_name); end

  class << self
    # Included hook to extend class methods
    #
    # source://celluloid-fsm//lib/celluloid/fsm.rb#23
    def included(klass); end
  end
end

# source://celluloid-fsm//lib/celluloid/fsm.rb#27
module Celluloid::FSM::ClassMethods
  # Obtain or set the default state
  # Passing a state name sets the default state
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#30
  def default_state(new_default = T.unsafe(nil)); end

  # Declare an FSM state and optionally provide a callback block to fire
  # Options:
  # * to: a state or array of states this state can transition to
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#46
  def state(*args, &block); end

  # Obtain the valid states for this FSM
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#39
  def states; end
end

# Default state name unless one is explicitly set
#
# source://celluloid-fsm//lib/celluloid/fsm.rb#20
Celluloid::FSM::DEFAULT_STATE = T.let(T.unsafe(nil), Symbol)

# FSM states as declared by Celluloid::FSM.state
#
# source://celluloid-fsm//lib/celluloid/fsm.rb#166
class Celluloid::FSM::State
  # @return [State] a new instance of State
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#169
  def initialize(name, transitions = T.unsafe(nil), &block); end

  # source://celluloid-fsm//lib/celluloid/fsm.rb#175
  def call(obj); end

  # Returns the value of attribute name.
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#167
  def name; end

  # Returns the value of attribute transitions.
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#167
  def transitions; end

  # @return [Boolean]
  #
  # source://celluloid-fsm//lib/celluloid/fsm.rb#179
  def valid_transition?(new_state); end
end

# Not attached to an actor
#
# source://celluloid-fsm//lib/celluloid/fsm.rb#18
class Celluloid::FSM::UnattachedError < ::Celluloid::Error; end
